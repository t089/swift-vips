//
//  foreign_jpeg.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Load jpeg from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - shrink: Shrink factor on load
    ///   - autorotate: Rotate image using exif orientation
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jpegload(filename: String, shrink: Int = 0, autorotate: Bool = false, unlimited: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if shrink != 0 {
                opt.set("shrink", value: shrink)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if unlimited != false {
                opt.set("unlimited", value: unlimited)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jpegload", options: &opt)
        }
    }

    /// Load jpeg from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - shrink: Shrink factor on load
    ///   - autorotate: Rotate image using exif orientation
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jpegloadBuffer(buffer: Data, shrink: Int = 0, autorotate: Bool = false, unlimited: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if shrink != 0 {
                opt.set("shrink", value: shrink)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if unlimited != false {
                opt.set("unlimited", value: unlimited)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jpegload_buffer", options: &opt)
        }
    }

    /// Load image from jpeg source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - shrink: Shrink factor on load
    ///   - autorotate: Rotate image using exif orientation
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jpegloadSource(source: VIPSSource, shrink: Int = 0, autorotate: Bool = false, unlimited: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if shrink != 0 {
                opt.set("shrink", value: shrink)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if unlimited != false {
                opt.set("unlimited", value: unlimited)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jpegload_source", options: &opt)
        }
    }

    /// Save image to jpeg file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - Q: Q factor
    ///   - optimizeCoding: Compute optimal Huffman coding tables
    ///   - interlace: Generate an interlaced (progressive) jpeg
    ///   - trellisQuant: Apply trellis quantisation to each 8x8 block
    ///   - overshootDeringing: Apply overshooting to samples with extreme values
    ///   - optimizeScans: Split spectrum of DCT coefficients into separate scans
    ///   - quantTable: Use predefined quantization table with given index
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - restartInterval: Add restart markers every specified number of mcu
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jpegsave(filename: String, Q: Int = 0, optimizeCoding: Bool = false, interlace: Bool = false, trellisQuant: Bool = false, overshootDeringing: Bool = false, optimizeScans: Bool = false, quantTable: Int = 0, subsampleMode: VipsForeignSubsample? = nil, restartInterval: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if optimizeCoding != false {
                opt.set("optimize_coding", value: optimizeCoding)
            }
            if interlace != false {
                opt.set("interlace", value: interlace)
            }
            if trellisQuant != false {
                opt.set("trellis_quant", value: trellisQuant)
            }
            if overshootDeringing != false {
                opt.set("overshoot_deringing", value: overshootDeringing)
            }
            if optimizeScans != false {
                opt.set("optimize_scans", value: optimizeScans)
            }
            if quantTable != 0 {
                opt.set("quant_table", value: quantTable)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if restartInterval != 0 {
                opt.set("restart_interval", value: restartInterval)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jpegsave", options: &opt)
    }

    /// Save image to jpeg buffer
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - optimizeCoding: Compute optimal Huffman coding tables
    ///   - interlace: Generate an interlaced (progressive) jpeg
    ///   - trellisQuant: Apply trellis quantisation to each 8x8 block
    ///   - overshootDeringing: Apply overshooting to samples with extreme values
    ///   - optimizeScans: Split spectrum of DCT coefficients into separate scans
    ///   - quantTable: Use predefined quantization table with given index
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - restartInterval: Add restart markers every specified number of mcu
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jpegsaveBuffer(Q: Int = 0, optimizeCoding: Bool = false, interlace: Bool = false, trellisQuant: Bool = false, overshootDeringing: Bool = false, optimizeScans: Bool = false, quantTable: Int = 0, subsampleMode: VipsForeignSubsample? = nil, restartInterval: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if optimizeCoding != false {
                opt.set("optimize_coding", value: optimizeCoding)
            }
            if interlace != false {
                opt.set("interlace", value: interlace)
            }
            if trellisQuant != false {
                opt.set("trellis_quant", value: trellisQuant)
            }
            if overshootDeringing != false {
                opt.set("overshoot_deringing", value: overshootDeringing)
            }
            if optimizeScans != false {
                opt.set("optimize_scans", value: optimizeScans)
            }
            if quantTable != 0 {
                opt.set("quant_table", value: quantTable)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if restartInterval != 0 {
                opt.set("restart_interval", value: restartInterval)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jpegsave_buffer", options: &opt)
    }

    /// Save image to jpeg mime
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - optimizeCoding: Compute optimal Huffman coding tables
    ///   - interlace: Generate an interlaced (progressive) jpeg
    ///   - trellisQuant: Apply trellis quantisation to each 8x8 block
    ///   - overshootDeringing: Apply overshooting to samples with extreme values
    ///   - optimizeScans: Split spectrum of DCT coefficients into separate scans
    ///   - quantTable: Use predefined quantization table with given index
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - restartInterval: Add restart markers every specified number of mcu
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jpegsaveMime(Q: Int = 0, optimizeCoding: Bool = false, interlace: Bool = false, trellisQuant: Bool = false, overshootDeringing: Bool = false, optimizeScans: Bool = false, quantTable: Int = 0, subsampleMode: VipsForeignSubsample? = nil, restartInterval: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if optimizeCoding != false {
                opt.set("optimize_coding", value: optimizeCoding)
            }
            if interlace != false {
                opt.set("interlace", value: interlace)
            }
            if trellisQuant != false {
                opt.set("trellis_quant", value: trellisQuant)
            }
            if overshootDeringing != false {
                opt.set("overshoot_deringing", value: overshootDeringing)
            }
            if optimizeScans != false {
                opt.set("optimize_scans", value: optimizeScans)
            }
            if quantTable != 0 {
                opt.set("quant_table", value: quantTable)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if restartInterval != 0 {
                opt.set("restart_interval", value: restartInterval)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jpegsave_mime", options: &opt)
    }

    /// Save image to jpeg target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - Q: Q factor
    ///   - optimizeCoding: Compute optimal Huffman coding tables
    ///   - interlace: Generate an interlaced (progressive) jpeg
    ///   - trellisQuant: Apply trellis quantisation to each 8x8 block
    ///   - overshootDeringing: Apply overshooting to samples with extreme values
    ///   - optimizeScans: Split spectrum of DCT coefficients into separate scans
    ///   - quantTable: Use predefined quantization table with given index
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - restartInterval: Add restart markers every specified number of mcu
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jpegsaveTarget(target: VIPSTarget, Q: Int = 0, optimizeCoding: Bool = false, interlace: Bool = false, trellisQuant: Bool = false, overshootDeringing: Bool = false, optimizeScans: Bool = false, quantTable: Int = 0, subsampleMode: VipsForeignSubsample? = nil, restartInterval: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if optimizeCoding != false {
                opt.set("optimize_coding", value: optimizeCoding)
            }
            if interlace != false {
                opt.set("interlace", value: interlace)
            }
            if trellisQuant != false {
                opt.set("trellis_quant", value: trellisQuant)
            }
            if overshootDeringing != false {
                opt.set("overshoot_deringing", value: overshootDeringing)
            }
            if optimizeScans != false {
                opt.set("optimize_scans", value: optimizeScans)
            }
            if quantTable != 0 {
                opt.set("quant_table", value: quantTable)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if restartInterval != 0 {
                opt.set("restart_interval", value: restartInterval)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jpegsave_target", options: &opt)
    }

}

//
//  foreign_other.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImage {

    /// Load an Analyze 6.0 file. If `filename` is "fred.img", this will look for
    /// an image header called "fred.hdr" and pixel data in "fred.img". You can
    /// also load "fred" or "fred.hdr".
    ///
    /// Images are
    /// loaded lazilly and byte-swapped, if necessary. The Analyze metadata is read
    /// and attached.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func analyzeload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("analyzeload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `skip`: skip this many lines at start of file
    /// * `lines`: read this many lines from file
    /// * `whitespace`: set of whitespace characters
    /// * `separator`: set of separator characters
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    ///
    /// Load a CSV (comma-separated values) file. The output image is always 1
    /// band (monochrome), `VIPS_FORMAT_DOUBLE`. Use vips_bandfold() to turn
    /// RGBRGBRGB mono images into colour iamges.
    ///
    /// Items in lines can be either floating point numbers in the C locale, or
    /// strings enclosed in double-quotes ("), or empty.
    /// You can use a backslash (\) within the quotes to escape special characters,
    /// such as quote marks.
    ///
    /// `skip` sets the number of lines to skip at the start of the file.
    /// Default zero.
    ///
    /// `lines` sets the number of lines to read from the file. Default -1,
    /// meaning read all lines to end of file.
    ///
    /// `whitespace` sets the skippable whitespace characters.
    /// Default space.
    /// Whitespace characters are always run together.
    ///
    /// `separator` sets the characters that separate fields.
    /// Default ;,tab. Separators are never run together.
    ///
    /// Use `fail_on` to set the type of error that will cause load to fail. By
    /// default, loaders are permissive, that is, `VIPS_FAIL_ON_NONE`.
    ///
    /// See also: vips_image_new_from_file(), vips_bandfold().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(filename: String, skip: Int? = nil, lines: Int? = nil, whitespace: String? = nil, separator: String? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `skip`: skip this many lines at start of file
    /// * `lines`: read this many lines from file
    /// * `whitespace`: set of whitespace characters
    /// * `separator`: set of separator characters
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    ///
    /// Exactly as vips_csvload(), but read from a source.
    ///
    /// See also: vips_csvload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(source: VIPSSource, skip: Int? = nil, lines: Int? = nil, whitespace: String? = nil, separator: String? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload_source", options: &opt)
        }
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(filename: String, separator: String? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave", options: &opt)
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(target: VIPSTarget, separator: String? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave_target", options: &opt)
    }

    /// Save image to deepzoom file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(filename: String, imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave", options: &opt)
    }

    /// Save image to dz buffer
    ///
    /// - Parameters:
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("dzsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from dzsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to deepzoom target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(target: VIPSTarget, imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave_target", options: &opt)
    }

    /// Read a FITS image file into a VIPS image.
    ///
    /// This operation can read images with up to three dimensions. Any higher
    /// dimensions must be empty.
    ///
    /// It can read 8, 16 and 32-bit integer images, signed and unsigned, float and
    /// double.
    ///
    /// FITS metadata is attached with the "fits-" prefix.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload", options: &opt)
        }
    }

    /// Exactly as vips_fitsload(), but read from a source.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload_source", options: &opt)
        }
    }

    /// Save image to fits file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func fitssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("fitssave", options: &opt)
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    ///
    /// Read a JPEG2000 image. The loader supports 8, 16 and 32-bit int pixel
    /// values, signed and unsigned. It supports greyscale, RGB, YCC, CMYK and
    /// multispectral colour spaces. It will read any ICC profile on the image.
    ///
    /// It will only load images where all channels have the same format.
    ///
    /// Use `page` to set the page to load, where page 0 is the base resolution
    /// image and higher-numbered pages are x2 reductions. Use the metadata item
    /// "n-pages" to find the number of pyramid layers.
    ///
    /// Use `fail_on` to set the type of error that will cause load to fail. By
    /// default, loaders are permissive, that is, `VIPS_FAIL_ON_NONE`.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(filename: String, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    ///
    /// Exactly as vips_jp2kload(), but read from a buffer.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jp2kload(buffer: some Collection<UInt8>, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("jp2kload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try jp2kload(buffer: Array(buffer), page: page, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    ///
    /// Exactly as vips_jp2kload(), but read from a source.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(source: VIPSSource, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload_source", options: &opt)
        }
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(filename: String, tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave", options: &opt)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("jp2ksave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from jp2ksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(target: VIPSTarget, tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave_target", options: &opt)
    }

    /// Read a JPEG-XL image.
    ///
    /// The JPEG-XL loader and saver are experimental features and may change
    /// in future libvips versions.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(filename: String, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload", options: &opt)
        }
    }

    /// Exactly as vips_jxlload(), but read from a buffer.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jxlload(buffer: some Collection<UInt8>, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("jxlload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try jxlload(buffer: Array(buffer), page: page, n: n, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Exactly as vips_jxlload(), but read from a source.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(source: VIPSSource, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload_source", options: &opt)
        }
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(filename: String, tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave", options: &opt)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("jxlsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from jxlsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(target: VIPSTarget, tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave_target", options: &opt)
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load from this page
    /// * `n`: %gint, load this many pages
    /// * `density`: string, canvas resolution for rendering vector formats like SVG
    ///
    /// Read in an image using libMagick, the ImageMagick library. This library can
    /// read more than 80 file formats, including SVG, BMP, EPS, DICOM and many
    /// others.
    /// The reader can handle any ImageMagick image, including the float and double
    /// formats. It will work with any quantum size, including HDR. Any metadata
    /// attached to the libMagick image is copied on to the VIPS image.
    ///
    /// The reader should also work with most versions of GraphicsMagick. See the
    /// "--with-magickpackage" configure option.
    ///
    /// The file format is usually guessed from the filename suffix, or sniffed
    /// from the file contents.
    ///
    /// Normally it will only load the first image in a many-image sequence (such
    /// as a GIF or a PDF). Use `page` and `n` to set the start page and number of
    /// pages to load. Set `n` to -1 to load all pages from `page` onwards.
    ///
    /// `density` is "WxH" in DPI, e.g. "600x300" or "600" (default is "72x72"). See
    /// the [density
    /// docs](http://www.imagemagick.org/script/command-line-options.php`density`)
    /// on the imagemagick website.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickload(filename: String, density: String? = nil, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let density = density {
                opt.set("density", value: density)
            }
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("magickload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load from this page
    /// * `n`: %gint, load this many pages
    /// * `density`: string, canvas resolution for rendering vector formats like SVG
    ///
    /// Read an image memory block using libMagick into a VIPS image. Exactly as
    /// vips_magickload(), but read from a memory source.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// See also: vips_magickload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func magickload(buffer: some Collection<UInt8>, density: String? = nil, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let density = density {
                    opt.set("density", value: density)
                }
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("magickload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try magickload(buffer: Array(buffer), density: density, page: page, n: n, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Save file with imagemagick
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(filename: String, format: String? = nil, quality: Int? = nil, optimizeGifFrames: Bool? = nil, optimizeGifTransparency: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let format = format {
                opt.set("format", value: format)
            }
            if let quality = quality {
                opt.set("quality", value: quality)
            }
            if let optimizeGifFrames = optimizeGifFrames {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if let optimizeGifTransparency = optimizeGifTransparency {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("magicksave", options: &opt)
    }

    /// Save image to magick buffer
    ///
    /// - Parameters:
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(format: String? = nil, quality: Int? = nil, optimizeGifFrames: Bool? = nil, optimizeGifTransparency: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let format = format {
                opt.set("format", value: format)
            }
            if let quality = quality {
                opt.set("quality", value: quality)
            }
            if let optimizeGifFrames = optimizeGifFrames {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if let optimizeGifTransparency = optimizeGifTransparency {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("magicksave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from magicksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Read a Matlab save file into a VIPS image.
    ///
    /// This operation searches the save
    /// file for the first array variable with between 1 and 3 dimensions and loads
    /// it as an image. It will not handle complex images. It does not handle
    /// sparse matrices.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matload", options: &opt)
        }
    }

    /// Reads a matrix from a file.
    ///
    /// Matrix files have a simple format that's supposed to be easy to create with
    /// a text editor or a spreadsheet.
    ///
    /// The first line has four numbers for width, height, scale and
    /// offset (scale and offset may be omitted, in which case they default to 1.0
    /// and 0.0). Scale must be non-zero. Width and height must be positive
    /// integers. The numbers are separated by any mixture of spaces, commas,
    /// tabs and quotation marks ("). The scale and offset fields may be
    /// floating-point, and must use '.'
    /// as a decimal separator.
    ///
    /// Subsequent lines each hold one row of matrix data, with numbers again
    /// separated by any mixture of spaces, commas,
    /// tabs and quotation marks ("). The numbers may be floating-point, and must
    /// use '.'
    /// as a decimal separator.
    ///
    /// Extra characters at the ends of lines or at the end of the file are
    /// ignored.
    ///
    /// See also: vips_matrixload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload", options: &opt)
        }
    }

    /// Exactly as vips_matrixload(), but read from a source.
    ///
    /// See also: vips_matrixload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload_source", options: &opt)
        }
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave", options: &opt)
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave_target", options: &opt)
    }

    /// Read a OpenEXR file into a VIPS image.
    ///
    /// The reader can handle scanline and tiled OpenEXR images. It can't handle
    /// OpenEXR colour management, image attributes, many pixel formats, anything
    /// other than RGBA.
    ///
    /// This reader uses the rather limited OpenEXR C API. It should really be
    /// redone in C++.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openexrload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openexrload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `level`: %gint, load this level
    /// * `associated`: %gchararray, load this associated image
    /// * `attach_associated`: %gboolean, attach all associated images as metadata
    /// * `autocrop`: %gboolean, crop to image bounds
    ///
    /// Read a virtual slide supported by the OpenSlide library into a VIPS image.
    /// OpenSlide supports images in Aperio, Hamamatsu, MIRAX, Sakura, Trestle,
    /// and Ventana formats.
    ///
    /// To facilitate zooming, virtual slide formats include multiple scaled-down
    /// versions of the high-resolution image.  These are typically called
    /// "levels".  By default, vips_openslideload() reads the highest-resolution
    /// level (level 0).  Set `level` to the level number you want.
    ///
    /// In addition to the slide image itself, virtual slide formats sometimes
    /// include additional images, such as a scan of the slide's barcode.
    /// OpenSlide calls these "associated images".  To read an associated image,
    /// set `associated` to the image's name.
    /// A slide's associated images are listed in the
    /// "slide-associated-images" metadata item.
    ///
    /// If you set `attach_associated`, then all associated images are attached as
    /// metadata items. Use vips_image_get_image() on `out` to retrieve them. Images
    /// are attached as "openslide-associated-XXXXX", where XXXXX is the name of the
    /// associated image.
    ///
    /// The output of this operator is always RGBA.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(filename: String, level: Int? = nil, autocrop: Bool? = nil, associated: String? = nil, attachAssociated: Bool? = nil, rgb: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `level`: %gint, load this level
    /// * `associated`: %gchararray, load this associated image
    /// * `attach_associated`: %gboolean, attach all associated images as metadata
    /// * `autocrop`: %gboolean, crop to image bounds
    ///
    /// Exactly as vips_openslideload(), but read from a source.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(source: VIPSSource, level: Int? = nil, autocrop: Bool? = nil, associated: String? = nil, attachAssociated: Bool? = nil, rgb: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload_source", options: &opt)
        }
    }

    /// Read a PPM/PBM/PGM/PFM file into a VIPS image.
    ///
    /// It can read 1, 8, 16 and 32 bit images, colour or monochrome,
    /// stored in binary or in ASCII. One bit images become 8 bit VIPS images,
    /// with 0 and 255 for 0 and 1.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `skip`: skip this many lines at start of file
    /// * `lines`: read this many lines from file
    /// * `whitespace`: set of whitespace characters
    /// * `separator`: set of separator characters
    /// * `fail`: %gboolean, fail on errors
    ///
    /// Exactly as vips_ppmload(), but read from a source.
    ///
    /// See also: vips_ppmload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload_source", options: &opt)
        }
    }

    /// Save image to ppm file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(filename: String, format: VipsForeignPpmFormat? = nil, ascii: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let format = format {
                opt.set("format", value: format)
            }
            if let ascii = ascii {
                opt.set("ascii", value: ascii)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave", options: &opt)
    }

    /// Save to ppm
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(target: VIPSTarget, format: VipsForeignPpmFormat? = nil, ascii: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let format = format {
                opt.set("format", value: format)
            }
            if let ascii = ascii {
                opt.set("ascii", value: ascii)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave_target", options: &opt)
    }

    /// Load a named profile.
    ///
    /// Profiles are loaded from four sources:
    ///
    /// - The special name `"none"` means no profile. `profile` will be `NULL` in this
    ///   case.
    ///
    /// - `name` can be the name of one of the ICC profiles embedded in libvips.
    ///   These names can be at least `"cmyk"`, `"p3"` and `"srgb"`.
    ///
    /// - `name` can be the full path to a file.
    ///
    /// - `name` can be the name of an ICC profile in the system profile directory
    ///   for your platform.
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - name: Profile name
    public static func profileLoad(name: String) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("name", value: name)
            opt.set("profile", value: &out)

            try VIPSImage.call("profile_load", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from profile_load")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Read a Radiance (HDR) file into a VIPS image.
    ///
    /// Radiance files are read as `VIPS_CODING_RAD`. They have one byte for each of
    /// red, green and blue, and one byte of shared exponent. Some operations (like
    /// vips_extract_area()) can work directly with images in this format, but
    /// mmany (all the arithmetic operations, for example) will not. Unpack
    /// `VIPS_CODING_RAD` images to 3 band float with vips_rad2float() if
    /// you want to do arithmetic on them.
    ///
    /// This operation ignores some header fields, like VIEW and DATE. It will not
    /// rotate/flip as the FORMAT string asks.
    ///
    /// Sections of this reader from Greg Ward and Radiance with kind permission.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload", options: &opt)
        }
    }

    /// Exactly as vips_radload(), but read from a HDR-formatted memory block.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// See also: vips_radload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func radload(buffer: some Collection<UInt8>, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("radload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try radload(buffer: Array(buffer), memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Exactly as vips_radload(), but read from a source.
    ///
    /// See also: vips_radload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload_source", options: &opt)
        }
    }

    /// Save image to radiance file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave", options: &opt)
    }

    /// Save image to radiance buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("radsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from radsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to radiance target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave_target", options: &opt)
    }

    /// Optional arguments:
    ///
    /// * `offset`: %guint64, offset in bytes from start of file
    /// * `format`: `VipsBandFormat`, set image format
    /// * `interpretation`: `VipsInterpretation`, set image interpretation
    ///
    /// This operation mmaps the file, setting up `out` so that access to that
    /// image will read from the file.
    ///
    /// By default, it assumes uchar pixels. Use `format` to select something else.
    ///
    /// The image will be tagged as `VIPS_INTERPRETATION_MULTIBAND`. Use
    /// `interpretation` to select something else.
    ///
    /// Use vips_byteswap() to reverse the byte ordering if necessary.
    ///
    /// See also: vips_image_new_from_file(), vips_copy(), vips_byteswap().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - offset: Offset in bytes from start of file
    ///   - format: Pixel format in image
    ///   - interpretation: Pixel interpretation
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func rawload(filename: String, width: Int, height: Int, bands: Int, offset: UInt64? = nil, format: VipsBandFormat? = nil, interpretation: VipsInterpretation? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("bands", value: bands)
            if let offset = offset {
                opt.set("offset", value: offset)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("rawload", options: &opt)
        }
    }

    /// Save image to raw file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave", options: &opt)
    }

    /// Write raw image to buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("rawsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from rawsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Write raw image to target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave_target", options: &opt)
    }

    /// Read in a vips image.
    ///
    /// See also: vips_vipssave().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload", options: &opt)
        }
    }

    /// Exactly as vips_vipsload(), but read from a source.
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload_source", options: &opt)
        }
    }

    /// Save image to file in vips format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave", options: &opt)
    }

    /// Save image to target in vips format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave_target", options: &opt)
    }

}

//
//  foreign_other.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImage {

    /// Load an analyze6 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func analyzeload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("analyzeload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(filename: String, skip: Int? = nil, lines: Int? = nil, whitespace: String? = nil, separator: String? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(source: VIPSSource, skip: Int? = nil, lines: Int? = nil, whitespace: String? = nil, separator: String? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload_source", options: &opt)
        }
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(filename: String, separator: String? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave", options: &opt)
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(target: VIPSTarget, separator: String? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave_target", options: &opt)
    }

    /// Save image to deepzoom file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(filename: String, imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave", options: &opt)
    }

    /// Save image to dz buffer
    ///
    /// - Parameters:
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("dzsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from dzsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to deepzoom target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(target: VIPSTarget, imagename: String? = nil, layout: VipsForeignDzLayout? = nil, suffix: String? = nil, overlap: Int? = nil, tileSize: Int? = nil, centre: Bool? = nil, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int? = nil, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int? = nil, id: String? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let imagename = imagename {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if let suffix = suffix {
                opt.set("suffix", value: suffix)
            }
            if let overlap = overlap {
                opt.set("overlap", value: overlap)
            }
            if let tileSize = tileSize {
                opt.set("tile_size", value: tileSize)
            }
            if let centre = centre {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let skipBlanks = skipBlanks {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if let id = id {
                opt.set("id", value: id)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave_target", options: &opt)
    }

    /// Load a fits image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload", options: &opt)
        }
    }

    /// Load fits from a source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload_source", options: &opt)
        }
    }

    /// Save image to fits file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func fitssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("fitssave", options: &opt)
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(filename: String, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload", options: &opt)
        }
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jp2kload(buffer: some Collection<UInt8>, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("jp2kload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try jp2kload(buffer: Array(buffer), page: page, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(source: VIPSSource, page: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload_source", options: &opt)
        }
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(filename: String, tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave", options: &opt)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("jp2ksave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from jp2ksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(target: VIPSTarget, tileWidth: Int? = nil, tileHeight: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave_target", options: &opt)
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(filename: String, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload", options: &opt)
        }
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jxlload(buffer: some Collection<UInt8>, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("jxlload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try jxlload(buffer: Array(buffer), page: page, n: n, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(source: VIPSSource, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload_source", options: &opt)
        }
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(filename: String, tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave", options: &opt)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("jxlsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from jxlsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(target: VIPSTarget, tier: Int? = nil, distance: Double? = nil, effort: Int? = nil, lossless: Bool? = nil, Q: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let tier = tier {
                opt.set("tier", value: tier)
            }
            if let distance = distance {
                opt.set("distance", value: distance)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave_target", options: &opt)
    }

    /// Load file with imagemagick7
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickload(filename: String, density: String? = nil, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let density = density {
                opt.set("density", value: density)
            }
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("magickload", options: &opt)
        }
    }

    /// Load buffer with imagemagick7
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func magickload(buffer: some Collection<UInt8>, density: String? = nil, page: Int? = nil, n: Int? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let density = density {
                    opt.set("density", value: density)
                }
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("magickload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try magickload(buffer: Array(buffer), density: density, page: page, n: n, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Save file with imagemagick
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(filename: String, format: String? = nil, quality: Int? = nil, optimizeGifFrames: Bool? = nil, optimizeGifTransparency: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let format = format {
                opt.set("format", value: format)
            }
            if let quality = quality {
                opt.set("quality", value: quality)
            }
            if let optimizeGifFrames = optimizeGifFrames {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if let optimizeGifTransparency = optimizeGifTransparency {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("magicksave", options: &opt)
    }

    /// Save image to magick buffer
    ///
    /// - Parameters:
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(format: String? = nil, quality: Int? = nil, optimizeGifFrames: Bool? = nil, optimizeGifTransparency: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let format = format {
                opt.set("format", value: format)
            }
            if let quality = quality {
                opt.set("quality", value: quality)
            }
            if let optimizeGifFrames = optimizeGifFrames {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if let optimizeGifTransparency = optimizeGifTransparency {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("magicksave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from magicksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Load mat from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload_source", options: &opt)
        }
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave", options: &opt)
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave_target", options: &opt)
    }

    /// Load an openexr image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openexrload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openexrload", options: &opt)
        }
    }

    /// Load file with openslide
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(filename: String, level: Int? = nil, autocrop: Bool? = nil, associated: String? = nil, attachAssociated: Bool? = nil, rgb: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload", options: &opt)
        }
    }

    /// Load source with openslide
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(source: VIPSSource, level: Int? = nil, autocrop: Bool? = nil, associated: String? = nil, attachAssociated: Bool? = nil, rgb: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload_source", options: &opt)
        }
    }

    /// Load ppm from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload", options: &opt)
        }
    }

    /// Load ppm base class
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload_source", options: &opt)
        }
    }

    /// Save image to ppm file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(filename: String, format: VipsForeignPpmFormat? = nil, ascii: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let format = format {
                opt.set("format", value: format)
            }
            if let ascii = ascii {
                opt.set("ascii", value: ascii)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave", options: &opt)
    }

    /// Save to ppm
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(target: VIPSTarget, format: VipsForeignPpmFormat? = nil, ascii: Bool? = nil, bitdepth: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let format = format {
                opt.set("format", value: format)
            }
            if let ascii = ascii {
                opt.set("ascii", value: ascii)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave_target", options: &opt)
    }

    /// Load named icc profile
    ///
    /// - Parameters:
    ///   - name: Profile name
    public static func profileLoad(name: String) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("name", value: name)
            opt.set("profile", value: &out)

            try VIPSImage.call("profile_load", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from profile_load")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Load a radiance image from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload", options: &opt)
        }
    }

    /// Load rad from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func radload(buffer: some Collection<UInt8>, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("radload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try radload(buffer: Array(buffer), memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Load rad from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload_source", options: &opt)
        }
    }

    /// Save image to radiance file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave", options: &opt)
    }

    /// Save image to radiance buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("radsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from radsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to radiance target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave_target", options: &opt)
    }

    /// Load raw data from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - offset: Offset in bytes from start of file
    ///   - format: Pixel format in image
    ///   - interpretation: Pixel interpretation
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func rawload(filename: String, width: Int, height: Int, bands: Int, offset: UInt64? = nil, format: VipsBandFormat? = nil, interpretation: VipsInterpretation? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("bands", value: bands)
            if let offset = offset {
                opt.set("offset", value: offset)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("rawload", options: &opt)
        }
    }

    /// Save image to raw file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave", options: &opt)
    }

    /// Write raw image to buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("rawsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from rawsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Write raw image to target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave_target", options: &opt)
    }

    /// Load vips from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(filename: String, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload", options: &opt)
        }
    }

    /// Load vips from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(source: VIPSSource, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload_source", options: &opt)
        }
    }

    /// Save image to file in vips format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave", options: &opt)
    }

    /// Save image to target in vips format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave_target", options: &opt)
    }

}

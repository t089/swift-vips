//
//  foreign_other.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Load an analyze6 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func analyzeload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("analyzeload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(filename: String, skip: Int = 0, lines: Int = 0, whitespace: String = "", separator: String = "", memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if skip != 0 {
                opt.set("skip", value: skip)
            }
            if lines != 0 {
                opt.set("lines", value: lines)
            }
            if whitespace != "" {
                opt.set("whitespace", value: whitespace)
            }
            if separator != "" {
                opt.set("separator", value: separator)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvloadSource(source: VIPSSource, skip: Int = 0, lines: Int = 0, whitespace: String = "", separator: String = "", memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if skip != 0 {
                opt.set("skip", value: skip)
            }
            if lines != 0 {
                opt.set("lines", value: lines)
            }
            if whitespace != "" {
                opt.set("whitespace", value: whitespace)
            }
            if separator != "" {
                opt.set("separator", value: separator)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("csvload_source", options: &opt)
        }
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(filename: String, separator: String = "", keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if separator != "" {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave", options: &opt)
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsaveTarget(target: VIPSTarget, separator: String = "", keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if separator != "" {
                opt.set("separator", value: separator)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("csvsave_target", options: &opt)
    }

    /// Save image to deepzoom file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(filename: String, imagename: String = "", layout: VipsForeignDzLayout? = nil, suffix: String = "", overlap: Int = 0, tileSize: Int = 0, centre: Bool = false, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int = 0, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int = 0, id: String = "", Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if imagename != "" {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if suffix != "" {
                opt.set("suffix", value: suffix)
            }
            if overlap != 0 {
                opt.set("overlap", value: overlap)
            }
            if tileSize != 0 {
                opt.set("tile_size", value: tileSize)
            }
            if centre != false {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if compression != 0 {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if skipBlanks != 0 {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if id != "" {
                opt.set("id", value: id)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave", options: &opt)
    }

    /// Save image to dz buffer
    ///
    /// - Parameters:
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsaveBuffer(imagename: String = "", layout: VipsForeignDzLayout? = nil, suffix: String = "", overlap: Int = 0, tileSize: Int = 0, centre: Bool = false, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int = 0, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int = 0, id: String = "", Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if imagename != "" {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if suffix != "" {
                opt.set("suffix", value: suffix)
            }
            if overlap != 0 {
                opt.set("overlap", value: overlap)
            }
            if tileSize != 0 {
                opt.set("tile_size", value: tileSize)
            }
            if centre != false {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if compression != 0 {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if skipBlanks != 0 {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if id != "" {
                opt.set("id", value: id)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave_buffer", options: &opt)
    }

    /// Save image to deepzoom target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - Q: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsaveTarget(target: VIPSTarget, imagename: String = "", layout: VipsForeignDzLayout? = nil, suffix: String = "", overlap: Int = 0, tileSize: Int = 0, centre: Bool = false, depth: VipsForeignDzDepth? = nil, angle: VipsAngle? = nil, container: VipsForeignDzContainer? = nil, compression: Int = 0, regionShrink: VipsRegionShrink? = nil, skipBlanks: Int = 0, id: String = "", Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if imagename != "" {
                opt.set("imagename", value: imagename)
            }
            if let layout = layout {
                opt.set("layout", value: layout)
            }
            if suffix != "" {
                opt.set("suffix", value: suffix)
            }
            if overlap != 0 {
                opt.set("overlap", value: overlap)
            }
            if tileSize != 0 {
                opt.set("tile_size", value: tileSize)
            }
            if centre != false {
                opt.set("centre", value: centre)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let container = container {
                opt.set("container", value: container)
            }
            if compression != 0 {
                opt.set("compression", value: compression)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if skipBlanks != 0 {
                opt.set("skip_blanks", value: skipBlanks)
            }
            if id != "" {
                opt.set("id", value: id)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("dzsave_target", options: &opt)
    }

    /// Load a fits image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload", options: &opt)
        }
    }

    /// Load fits from a source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("fitsload_source", options: &opt)
        }
    }

    /// Save image to fits file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func fitssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("fitssave", options: &opt)
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(filename: String, page: Int = 0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if page != 0 {
                opt.set("page", value: page)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload", options: &opt)
        }
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kloadBuffer(buffer: Data, page: Int = 0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if page != 0 {
                opt.set("page", value: page)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload_buffer", options: &opt)
        }
    }

    /// Load jpeg2000 image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: Load this page from the image
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kloadSource(source: VIPSSource, page: Int = 0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if page != 0 {
                opt.set("page", value: page)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jp2kload_source", options: &opt)
        }
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(filename: String, tileWidth: Int = 0, tileHeight: Int = 0, lossless: Bool = false, Q: Int = 0, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave", options: &opt)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksaveBuffer(tileWidth: Int = 0, tileHeight: Int = 0, lossless: Bool = false, Q: Int = 0, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave_buffer", options: &opt)
    }

    /// Save image in jpeg2000 format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - Q: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksaveTarget(target: VIPSTarget, tileWidth: Int = 0, tileHeight: Int = 0, lossless: Bool = false, Q: Int = 0, subsampleMode: VipsForeignSubsample? = nil, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let subsampleMode = subsampleMode {
                opt.set("subsample_mode", value: subsampleMode)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jp2ksave_target", options: &opt)
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload", options: &opt)
        }
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlloadBuffer(buffer: Data, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload_buffer", options: &opt)
        }
    }

    /// Load jpeg-xl image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("jxlload_source", options: &opt)
        }
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(filename: String, tier: Int = 0, distance: Double = 0.0, effort: Int = 0, lossless: Bool = false, Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if tier != 0 {
                opt.set("tier", value: tier)
            }
            if distance != 0.0 {
                opt.set("distance", value: distance)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave", options: &opt)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsaveBuffer(tier: Int = 0, distance: Double = 0.0, effort: Int = 0, lossless: Bool = false, Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if tier != 0 {
                opt.set("tier", value: tier)
            }
            if distance != 0.0 {
                opt.set("distance", value: distance)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave_buffer", options: &opt)
    }

    /// Save image in jpeg-xl format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - Q: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsaveTarget(target: VIPSTarget, tier: Int = 0, distance: Double = 0.0, effort: Int = 0, lossless: Bool = false, Q: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if tier != 0 {
                opt.set("tier", value: tier)
            }
            if distance != 0.0 {
                opt.set("distance", value: distance)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("jxlsave_target", options: &opt)
    }

    /// Load file with imagemagick
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickload(filename: String, density: String = "", page: Int = 0, n: Int = 0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if density != "" {
                opt.set("density", value: density)
            }
            if page != 0 {
                opt.set("page", value: page)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("magickload", options: &opt)
        }
    }

    /// Load buffer with imagemagick
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickloadBuffer(buffer: Data, density: String = "", page: Int = 0, n: Int = 0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if density != "" {
                opt.set("density", value: density)
            }
            if page != 0 {
                opt.set("page", value: page)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("magickload_buffer", options: &opt)
        }
    }

    /// Save file with imagemagick
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(filename: String, format: String = "", quality: Int = 0, optimizeGifFrames: Bool = false, optimizeGifTransparency: Bool = false, bitdepth: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if format != "" {
                opt.set("format", value: format)
            }
            if quality != 0 {
                opt.set("quality", value: quality)
            }
            if optimizeGifFrames != false {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if optimizeGifTransparency != false {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("magicksave", options: &opt)
    }

    /// Save image to magick buffer
    ///
    /// - Parameters:
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksaveBuffer(format: String = "", quality: Int = 0, optimizeGifFrames: Bool = false, optimizeGifTransparency: Bool = false, bitdepth: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if format != "" {
                opt.set("format", value: format)
            }
            if quality != 0 {
                opt.set("quality", value: quality)
            }
            if optimizeGifFrames != false {
                opt.set("optimize_gif_frames", value: optimizeGifFrames)
            }
            if optimizeGifTransparency != false {
                opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("magicksave_buffer", options: &opt)
    }

    /// Load mat from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("matrixload_source", options: &opt)
        }
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave", options: &opt)
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsaveTarget(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("matrixsave_target", options: &opt)
    }

    /// Load an openexr image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openexrload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openexrload", options: &opt)
        }
    }

    /// Load file with openslide
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(filename: String, level: Int = 0, autocrop: Bool = false, associated: String = "", attachAssociated: Bool = false, rgb: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if level != 0 {
                opt.set("level", value: level)
            }
            if autocrop != false {
                opt.set("autocrop", value: autocrop)
            }
            if associated != "" {
                opt.set("associated", value: associated)
            }
            if attachAssociated != false {
                opt.set("attach_associated", value: attachAssociated)
            }
            if rgb != false {
                opt.set("rgb", value: rgb)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload", options: &opt)
        }
    }

    /// Load source with openslide
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideloadSource(source: VIPSSource, level: Int = 0, autocrop: Bool = false, associated: String = "", attachAssociated: Bool = false, rgb: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if level != 0 {
                opt.set("level", value: level)
            }
            if autocrop != false {
                opt.set("autocrop", value: autocrop)
            }
            if associated != "" {
                opt.set("associated", value: associated)
            }
            if attachAssociated != false {
                opt.set("attach_associated", value: attachAssociated)
            }
            if rgb != false {
                opt.set("rgb", value: rgb)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("openslideload_source", options: &opt)
        }
    }

    /// Load ppm from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload", options: &opt)
        }
    }

    /// Load ppm base class
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ppmload_source", options: &opt)
        }
    }

    /// Save image to ppm file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(filename: String, format: VipsForeignPpmFormat? = nil, ascii: Bool = false, bitdepth: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let format = format {
                opt.set("format", value: format)
            }
            if ascii != false {
                opt.set("ascii", value: ascii)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave", options: &opt)
    }

    /// Save to ppm
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsaveTarget(target: VIPSTarget, format: VipsForeignPpmFormat? = nil, ascii: Bool = false, bitdepth: Int = 0, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if let format = format {
                opt.set("format", value: format)
            }
            if ascii != false {
                opt.set("ascii", value: ascii)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("ppmsave_target", options: &opt)
    }

    /// Load named icc profile
    ///
    /// - Parameters:
    ///   - name: Profile name
    public static func profileLoad(name: String) throws -> Data {
        try VIPSImage.execute {
            var opt = VIPSOption()

            opt.set("name", value: name)

            try VIPSImage.call("profile_load", options: &opt)
        }
    }

    /// Load a radiance image from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload", options: &opt)
        }
    }

    /// Load rad from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radloadBuffer(buffer: Data, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload_buffer", options: &opt)
        }
    }

    /// Load rad from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("radload_source", options: &opt)
        }
    }

    /// Save image to radiance file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave", options: &opt)
    }

    /// Save image to radiance buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsaveBuffer(keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave_buffer", options: &opt)
    }

    /// Save image to radiance target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsaveTarget(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("radsave_target", options: &opt)
    }

    /// Load raw data from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - offset: Offset in bytes from start of file
    ///   - format: Pixel format in image
    ///   - interpretation: Pixel interpretation
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func rawload(filename: String, width: Int, height: Int, bands: Int, offset: UInt64? = nil, format: VipsBandFormat? = nil, interpretation: VipsInterpretation? = nil, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("bands", value: bands)
            if let offset = offset {
                opt.set("offset", value: offset)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("rawload", options: &opt)
        }
    }

    /// Save image to raw file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(filename: String, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave", options: &opt)
    }

    /// Write raw image to file descriptor
    ///
    /// - Parameters:
    ///   - fd: File descriptor to write to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsaveFd(fd: Int, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("fd", value: fd)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("rawsave_fd", options: &opt)
    }

    /// Load vips from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(filename: String, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload", options: &opt)
        }
    }

    /// Load vips from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsloadSource(source: VIPSSource, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("vipsload_source", options: &opt)
        }
    }

    /// Save image to file in vips format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(filename: String, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave", options: &opt)
    }

    /// Save image to target in vips format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssaveTarget(target: VIPSTarget, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("vipssave_target", options: &opt)
    }

}

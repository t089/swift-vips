//
//  foreign_other.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(
        filename: String,
        separator: String? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let separator = separator {
            opt.set("separator", value: separator)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("csvsave", options: &opt)
    }

    /// Save image to csv
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - separator: Separator characters
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func csvsave(
        target: VIPSTarget,
        separator: String? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let separator = separator {
            opt.set("separator", value: separator)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("csvsave_target", options: &opt)
    }

    /// Save image to deepzoom file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - quality: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(
        filename: String,
        imagename: String? = nil,
        layout: VipsForeignDzLayout? = nil,
        suffix: String? = nil,
        overlap: Int? = nil,
        tileSize: Int? = nil,
        centre: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        angle: VipsAngle? = nil,
        container: VipsForeignDzContainer? = nil,
        compression: Int? = nil,
        regionShrink: VipsRegionShrink? = nil,
        skipBlanks: Int? = nil,
        id: String? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let imagename = imagename {
            opt.set("imagename", value: imagename)
        }
        if let layout = layout {
            opt.set("layout", value: layout)
        }
        if let suffix = suffix {
            opt.set("suffix", value: suffix)
        }
        if let overlap = overlap {
            opt.set("overlap", value: overlap)
        }
        if let tileSize = tileSize {
            opt.set("tile_size", value: tileSize)
        }
        if let centre = centre {
            opt.set("centre", value: centre)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let angle = angle {
            opt.set("angle", value: angle)
        }
        if let container = container {
            opt.set("container", value: container)
        }
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let skipBlanks = skipBlanks {
            opt.set("skip_blanks", value: skipBlanks)
        }
        if let id = id {
            opt.set("id", value: id)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("dzsave", options: &opt)
    }

    /// Save image to dz buffer
    ///
    /// - Parameters:
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - quality: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(
        imagename: String? = nil,
        layout: VipsForeignDzLayout? = nil,
        suffix: String? = nil,
        overlap: Int? = nil,
        tileSize: Int? = nil,
        centre: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        angle: VipsAngle? = nil,
        container: VipsForeignDzContainer? = nil,
        compression: Int? = nil,
        regionShrink: VipsRegionShrink? = nil,
        skipBlanks: Int? = nil,
        id: String? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let imagename = imagename {
            opt.set("imagename", value: imagename)
        }
        if let layout = layout {
            opt.set("layout", value: layout)
        }
        if let suffix = suffix {
            opt.set("suffix", value: suffix)
        }
        if let overlap = overlap {
            opt.set("overlap", value: overlap)
        }
        if let tileSize = tileSize {
            opt.set("tile_size", value: tileSize)
        }
        if let centre = centre {
            opt.set("centre", value: centre)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let angle = angle {
            opt.set("angle", value: angle)
        }
        if let container = container {
            opt.set("container", value: container)
        }
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let skipBlanks = skipBlanks {
            opt.set("skip_blanks", value: skipBlanks)
        }
        if let id = id {
            opt.set("id", value: id)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("dzsave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from dzsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to deepzoom target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - imagename: Image name
    ///   - layout: Directory layout
    ///   - suffix: Filename suffix for tiles
    ///   - overlap: Tile overlap in pixels
    ///   - tileSize: Tile size in pixels
    ///   - centre: Center image in tile
    ///   - depth: Pyramid depth
    ///   - angle: Rotate image during save
    ///   - container: Pyramid container type
    ///   - compression: ZIP deflate compression level
    ///   - regionShrink: Method to shrink regions
    ///   - skipBlanks: Skip tiles which are nearly equal to the background
    ///   - id: Resource ID
    ///   - quality: Q factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func dzsave(
        target: VIPSTarget,
        imagename: String? = nil,
        layout: VipsForeignDzLayout? = nil,
        suffix: String? = nil,
        overlap: Int? = nil,
        tileSize: Int? = nil,
        centre: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        angle: VipsAngle? = nil,
        container: VipsForeignDzContainer? = nil,
        compression: Int? = nil,
        regionShrink: VipsRegionShrink? = nil,
        skipBlanks: Int? = nil,
        id: String? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let imagename = imagename {
            opt.set("imagename", value: imagename)
        }
        if let layout = layout {
            opt.set("layout", value: layout)
        }
        if let suffix = suffix {
            opt.set("suffix", value: suffix)
        }
        if let overlap = overlap {
            opt.set("overlap", value: overlap)
        }
        if let tileSize = tileSize {
            opt.set("tile_size", value: tileSize)
        }
        if let centre = centre {
            opt.set("centre", value: centre)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let angle = angle {
            opt.set("angle", value: angle)
        }
        if let container = container {
            opt.set("container", value: container)
        }
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let skipBlanks = skipBlanks {
            opt.set("skip_blanks", value: skipBlanks)
        }
        if let id = id {
            opt.set("id", value: id)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("dzsave_target", options: &opt)
    }

    /// Save image to fits file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func fitssave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("fitssave", options: &opt)
    }

    /// Save image in JPEG2000 format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - quality: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(
        filename: String,
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        subsampleMode: VipsForeignSubsample? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let subsampleMode = subsampleMode {
            opt.set("subsample_mode", value: subsampleMode)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("jp2ksave", options: &opt)
    }

    /// Save image in JPEG2000 format
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - quality: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        subsampleMode: VipsForeignSubsample? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let subsampleMode = subsampleMode {
            opt.set("subsample_mode", value: subsampleMode)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("jp2ksave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from jp2ksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in JPEG2000 format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - lossless: Enable lossless compression
    ///   - quality: Q factor
    ///   - subsampleMode: Select chroma subsample operation mode
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jp2ksave(
        target: VIPSTarget,
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        subsampleMode: VipsForeignSubsample? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let subsampleMode = subsampleMode {
            opt.set("subsample_mode", value: subsampleMode)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("jp2ksave_target", options: &opt)
    }

    /// Save image in JPEG-XL format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - quality: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(
        filename: String,
        tier: Int? = nil,
        distance: Double? = nil,
        effort: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let tier = tier {
            opt.set("tier", value: tier)
        }
        if let distance = distance {
            opt.set("distance", value: distance)
        }
        if let effort = effort {
            opt.set("effort", value: effort)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("jxlsave", options: &opt)
    }

    /// Save image in JPEG-XL format
    ///
    /// - Parameters:
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - quality: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(
        tier: Int? = nil,
        distance: Double? = nil,
        effort: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let tier = tier {
            opt.set("tier", value: tier)
        }
        if let distance = distance {
            opt.set("distance", value: distance)
        }
        if let effort = effort {
            opt.set("effort", value: effort)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("jxlsave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from jxlsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image in JPEG-XL format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - tier: Decode speed tier
    ///   - distance: Target butteraugli distance
    ///   - effort: Encoding effort
    ///   - lossless: Enable lossless compression
    ///   - quality: Quality factor
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func jxlsave(
        target: VIPSTarget,
        tier: Int? = nil,
        distance: Double? = nil,
        effort: Int? = nil,
        lossless: Bool? = nil,
        quality: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let tier = tier {
            opt.set("tier", value: tier)
        }
        if let distance = distance {
            opt.set("distance", value: distance)
        }
        if let effort = effort {
            opt.set("effort", value: effort)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("jxlsave_target", options: &opt)
    }

    /// Save file with ImageMagick
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(
        filename: String,
        format: String? = nil,
        quality: Int? = nil,
        optimizeGifFrames: Bool? = nil,
        optimizeGifTransparency: Bool? = nil,
        bitdepth: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let format = format {
            opt.set("format", value: format)
        }
        if let quality = quality {
            opt.set("quality", value: quality)
        }
        if let optimizeGifFrames = optimizeGifFrames {
            opt.set("optimize_gif_frames", value: optimizeGifFrames)
        }
        if let optimizeGifTransparency = optimizeGifTransparency {
            opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("magicksave", options: &opt)
    }

    /// Save image to magick buffer
    ///
    /// - Parameters:
    ///   - format: Format to save in
    ///   - quality: Quality to use
    ///   - optimizeGifFrames: Apply GIF frames optimization
    ///   - optimizeGifTransparency: Apply GIF transparency optimization
    ///   - bitdepth: Number of bits per pixel
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func magicksave(
        format: String? = nil,
        quality: Int? = nil,
        optimizeGifFrames: Bool? = nil,
        optimizeGifTransparency: Bool? = nil,
        bitdepth: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let format = format {
            opt.set("format", value: format)
        }
        if let quality = quality {
            opt.set("quality", value: quality)
        }
        if let optimizeGifFrames = optimizeGifFrames {
            opt.set("optimize_gif_frames", value: optimizeGifFrames)
        }
        if let optimizeGifTransparency = optimizeGifTransparency {
            opt.set("optimize_gif_transparency", value: optimizeGifTransparency)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("magicksave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from magicksave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("matrixsave", options: &opt)
    }

    /// Save image to matrix
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func matrixsave(
        target: VIPSTarget,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("matrixsave_target", options: &opt)
    }

    /// Save image to nifti file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func niftisave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("niftisave", options: &opt)
    }

    /// Save image to ppm file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(
        filename: String,
        format: VipsForeignPpmFormat? = nil,
        ascii: Bool? = nil,
        bitdepth: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let format = format {
            opt.set("format", value: format)
        }
        if let ascii = ascii {
            opt.set("ascii", value: ascii)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("ppmsave", options: &opt)
    }

    /// Save to ppm
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - format: Format to save in
    ///   - ascii: Save as ascii
    ///   - bitdepth: Set to 1 to write as a 1 bit image
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func ppmsave(
        target: VIPSTarget,
        format: VipsForeignPpmFormat? = nil,
        ascii: Bool? = nil,
        bitdepth: Int? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let format = format {
            opt.set("format", value: format)
        }
        if let ascii = ascii {
            opt.set("ascii", value: ascii)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("ppmsave_target", options: &opt)
    }

    /// Save image to Radiance file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("radsave", options: &opt)
    }

    /// Save image to Radiance buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("radsave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from radsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to Radiance target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func radsave(
        target: VIPSTarget,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("radsave_target", options: &opt)
    }

    /// Save image to raw file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("rawsave", options: &opt)
    }

    /// Write raw image to buffer
    ///
    /// - Parameters:
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("rawsave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from rawsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Write raw image to target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func rawsave(
        target: VIPSTarget,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("rawsave_target", options: &opt)
    }

    /// Save image to file in vips format
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(
        filename: String,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("vipssave", options: &opt)
    }

    /// Save image to target in vips format
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func vipssave(
        target: VIPSTarget,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("vipssave_target", options: &opt)
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Load an Analyze6 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func analyzeload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("analyzeload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(
        filename: String,
        skip: Int? = nil,
        lines: Int? = nil,
        whitespace: String? = nil,
        separator: String? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("csvload", options: &opt)
        }
    }

    /// Load csv
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - skip: Skip this many lines at the start of the file
    ///   - lines: Read this many lines from the file
    ///   - whitespace: Set of whitespace characters
    ///   - separator: Set of separator characters
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func csvload(
        source: VIPSSource,
        skip: Int? = nil,
        lines: Int? = nil,
        whitespace: String? = nil,
        separator: String? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let skip = skip {
                opt.set("skip", value: skip)
            }
            if let lines = lines {
                opt.set("lines", value: lines)
            }
            if let whitespace = whitespace {
                opt.set("whitespace", value: whitespace)
            }
            if let separator = separator {
                opt.set("separator", value: separator)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("csvload_source", options: &opt)
        }
    }

    /// Load a FITS image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("fitsload", options: &opt)
        }
    }

    /// Load FITS from a source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func fitsload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("fitsload_source", options: &opt)
        }
    }

    /// Load JPEG2000 image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: Load this page from the image
    ///   - oneshot: Load images a frame at a time
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(
        filename: String,
        page: Int? = nil,
        oneshot: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let oneshot = oneshot {
                opt.set("oneshot", value: oneshot)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("jp2kload", options: &opt)
        }
    }

    /// Load JPEG2000 image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: Load this page from the image
    ///   - oneshot: Load images a frame at a time
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(
        buffer: VIPSBlob,
        page: Int? = nil,
        oneshot: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let oneshot = oneshot {
                    opt.set("oneshot", value: oneshot)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("jp2kload_buffer", options: &opt)
            }
        }
    }

    /// Load JPEG2000 image without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: Load this page from the image
    ///   - oneshot: Load images a frame at a time
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jp2kload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        page: Int? = nil,
        oneshot: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try jp2kload(
            buffer: blob,
            page: page,
            oneshot: oneshot,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load JPEG2000 image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: Load this page from the image
    ///   - oneshot: Load images a frame at a time
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jp2kload(
        source: VIPSSource,
        page: Int? = nil,
        oneshot: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let oneshot = oneshot {
                opt.set("oneshot", value: oneshot)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("jp2kload_source", options: &opt)
        }
    }

    /// Load JPEG-XL image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(
        filename: String,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("jxlload", options: &opt)
        }
    }

    /// Load JPEG-XL image
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(
        buffer: VIPSBlob,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("jxlload_buffer", options: &opt)
            }
        }
    }

    /// Load JPEG-XL image without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func jxlload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try jxlload(
            buffer: blob,
            page: page,
            n: n,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load JPEG-XL image
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func jxlload(
        source: VIPSSource,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("jxlload_source", options: &opt)
        }
    }

    /// Load file with ImageMagick7
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickload(
        filename: String,
        density: String? = nil,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let density = density {
                opt.set("density", value: density)
            }
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("magickload", options: &opt)
        }
    }

    /// Load buffer with ImageMagick7
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func magickload(
        buffer: VIPSBlob,
        density: String? = nil,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let density = density {
                    opt.set("density", value: density)
                }
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("magickload_buffer", options: &opt)
            }
        }
    }

    /// Load buffer with ImageMagick7 without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - density: Canvas resolution for rendering vector formats like SVG
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func magickload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        density: String? = nil,
        page: Int? = nil,
        n: Int? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try magickload(
            buffer: blob,
            density: density,
            page: page,
            n: n,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load mat from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("matload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("matrixload", options: &opt)
        }
    }

    /// Load matrix
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func matrixload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("matrixload_source", options: &opt)
        }
    }

    /// Load NIfTI volume
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func niftiload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("niftiload", options: &opt)
        }
    }

    /// Load NIfTI volumes
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func niftiload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("niftiload_source", options: &opt)
        }
    }

    /// Load an OpenEXR image
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openexrload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("openexrload", options: &opt)
        }
    }

    /// Load file with OpenSlide
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(
        filename: String,
        level: Int? = nil,
        autocrop: Bool? = nil,
        associated: String? = nil,
        attachAssociated: Bool? = nil,
        rgb: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("openslideload", options: &opt)
        }
    }

    /// Load source with OpenSlide
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - level: Load this level from the file
    ///   - autocrop: Crop to image bounds
    ///   - associated: Load this associated image
    ///   - attachAssociated: Attach all associated images
    ///   - rgb: Output RGB (not RGBA)
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func openslideload(
        source: VIPSSource,
        level: Int? = nil,
        autocrop: Bool? = nil,
        associated: String? = nil,
        attachAssociated: Bool? = nil,
        rgb: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let level = level {
                opt.set("level", value: level)
            }
            if let autocrop = autocrop {
                opt.set("autocrop", value: autocrop)
            }
            if let associated = associated {
                opt.set("associated", value: associated)
            }
            if let attachAssociated = attachAssociated {
                opt.set("attach_associated", value: attachAssociated)
            }
            if let rgb = rgb {
                opt.set("rgb", value: rgb)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("openslideload_source", options: &opt)
        }
    }

    /// Load ppm from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("ppmload", options: &opt)
        }
    }

    /// Load ppm from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(
        buffer: VIPSBlob,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("ppmload_buffer", options: &opt)
            }
        }
    }

    /// Load ppm from buffer without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func ppmload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try ppmload(
            buffer: blob,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load ppm from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func ppmload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("ppmload_source", options: &opt)
        }
    }

    /// Load named ICC profile
    ///
    /// - Parameters:
    ///   - name: Profile name
    public static func profileLoad(name: String) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("name", value: name)
        opt.set("profile", value: out)

        try Self.call("profile_load", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from profile_load")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Load a Radiance image from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("radload", options: &opt)
        }
    }

    /// Load rad from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(
        buffer: VIPSBlob,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("radload_buffer", options: &opt)
            }
        }
    }

    /// Load rad from buffer without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func radload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try radload(
            buffer: blob,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load rad from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func radload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("radload_source", options: &opt)
        }
    }

    /// Load raw data from a file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - offset: Offset in bytes from start of file
    ///   - format: Pixel format in image
    ///   - interpretation: Pixel interpretation
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func rawload(
        filename: String,
        width: Int,
        height: Int,
        bands: Int,
        offset: UInt64? = nil,
        format: VipsBandFormat? = nil,
        interpretation: VipsInterpretation? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("bands", value: bands)
            if let offset = offset {
                opt.set("offset", value: offset)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("rawload", options: &opt)
        }
    }

    /// Load vips from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(
        filename: String,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("vipsload", options: &opt)
        }
    }

    /// Load vips from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func vipsload(
        source: VIPSSource,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("vipsload_source", options: &opt)
        }
    }

}

//
//  foreign_png.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImage {

    /// Optional arguments:
    ///
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    /// * `unlimited`: %gboolean, remove all denial of service limits
    ///
    /// Read a PNG file into a VIPS image. It can read all png images, including 8-
    /// and 16-bit images, 1 and 3 channel, with and without an alpha channel.
    ///
    /// Any ICC profile is read and attached to the VIPS image. It also supports
    /// XMP metadata.
    ///
    /// Use `fail_on` to set the type of error that will cause load to fail. By
    /// default, loaders are permissive, that is, `VIPS_FAIL_ON_NONE`.
    ///
    /// By default, the PNG loader limits the number of text and data chunks to
    /// block some denial of service attacks. Set `unlimited` to disable these
    /// limits.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func pngload(filename: String, unlimited: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let unlimited = unlimited {
                opt.set("unlimited", value: unlimited)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("pngload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    /// * `unlimited`: %gboolean, Remove all denial of service limits
    ///
    /// Exactly as vips_pngload(), but read from a PNG-formatted memory block.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// See also: vips_pngload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func pngload(buffer: some Collection<UInt8>, unlimited: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let unlimited = unlimited {
                    opt.set("unlimited", value: unlimited)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("pngload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try pngload(buffer: Array(buffer), unlimited: unlimited, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Optional arguments:
    ///
    /// * `fail_on`: `VipsFailOn`, types of read error to fail on
    /// * `unlimited`: %gboolean, Remove all denial of service limits
    ///
    /// Exactly as vips_pngload(), but read from a source.
    ///
    /// See also: vips_pngload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func pngload(source: VIPSSource, unlimited: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let unlimited = unlimited {
                opt.set("unlimited", value: unlimited)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("pngload_source", options: &opt)
        }
    }

    /// Save image to file as png
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - compression: Compression factor
    ///   - interlace: Interlace image
    ///   - filter: libspng row filter flag(s)
    ///   - palette: Quantise to 8bpp palette
    ///   - Q: Quantisation quality
    ///   - dither: Amount of dithering
    ///   - bitdepth: Write as a 1, 2, 4, 8 or 16 bit image
    ///   - effort: Quantisation CPU effort
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func pngsave(filename: String, compression: Int? = nil, interlace: Bool? = nil, filter: VipsForeignPngFilter? = nil, palette: Bool? = nil, Q: Int? = nil, dither: Double? = nil, bitdepth: Int? = nil, effort: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let interlace = interlace {
                opt.set("interlace", value: interlace)
            }
            if let filter = filter {
                opt.set("filter", value: filter)
            }
            if let palette = palette {
                opt.set("palette", value: palette)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let dither = dither {
                opt.set("dither", value: dither)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("pngsave", options: &opt)
    }

    /// Save image to buffer as png
    ///
    /// - Parameters:
    ///   - compression: Compression factor
    ///   - interlace: Interlace image
    ///   - filter: libspng row filter flag(s)
    ///   - palette: Quantise to 8bpp palette
    ///   - Q: Quantisation quality
    ///   - dither: Amount of dithering
    ///   - bitdepth: Write as a 1, 2, 4, 8 or 16 bit image
    ///   - effort: Quantisation CPU effort
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func pngsave(compression: Int? = nil, interlace: Bool? = nil, filter: VipsForeignPngFilter? = nil, palette: Bool? = nil, Q: Int? = nil, dither: Double? = nil, bitdepth: Int? = nil, effort: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let interlace = interlace {
                opt.set("interlace", value: interlace)
            }
            if let filter = filter {
                opt.set("filter", value: filter)
            }
            if let palette = palette {
                opt.set("palette", value: palette)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let dither = dither {
                opt.set("dither", value: dither)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("pngsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from pngsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to target as png
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - compression: Compression factor
    ///   - interlace: Interlace image
    ///   - filter: libspng row filter flag(s)
    ///   - palette: Quantise to 8bpp palette
    ///   - Q: Quantisation quality
    ///   - dither: Amount of dithering
    ///   - bitdepth: Write as a 1, 2, 4, 8 or 16 bit image
    ///   - effort: Quantisation CPU effort
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func pngsave(target: VIPSTarget, compression: Int? = nil, interlace: Bool? = nil, filter: VipsForeignPngFilter? = nil, palette: Bool? = nil, Q: Int? = nil, dither: Double? = nil, bitdepth: Int? = nil, effort: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let interlace = interlace {
                opt.set("interlace", value: interlace)
            }
            if let filter = filter {
                opt.set("filter", value: filter)
            }
            if let palette = palette {
                opt.set("palette", value: palette)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let dither = dither {
                opt.set("dither", value: dither)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("pngsave_target", options: &opt)
    }

}

//
//  foreign_tiff.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImage {

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `n`: %gint, load this many pages
    /// * `autorotate`: %gboolean, use orientation tag to rotate the image
    ///   during load
    /// * `subifd`: %gint, select this subifd index
    ///
    /// Read a TIFF file into a VIPS image. It is a full baseline TIFF 6 reader,
    /// with extensions for tiled images, multipage images, XYZ and LAB colour
    /// space, pyramidal images and JPEG compression, including CMYK and YCbCr.
    ///
    /// `page` means load this page from the file. By default the first page (page
    /// 0) is read.
    ///
    /// `n` means load this many pages. By default a single page is read. All the
    /// pages must have the same dimensions, and they are loaded as a tall, thin
    /// "toilet roll" image. The `VIPS_META_PAGE_HEIGHT` metadata
    /// tag gives the height in pixels of each page. Use -1 to load all pages.
    ///
    /// Setting `autorotate` to `TRUE` will make the loader interpret the
    /// orientation tag and automatically rotate the image appropriately during
    /// load.
    ///
    /// If `autorotate` is `FALSE`, the metadata field `VIPS_META_ORIENTATION` is set
    /// to the value of the orientation tag. Applications may read and interpret
    /// this field
    /// as they wish later in processing. See vips_autorot(). Save
    /// operations will use `VIPS_META_ORIENTATION`, if present, to set the
    /// orientation of output images.
    ///
    /// If `autorotate` is TRUE, the image will be rotated upright during load and
    /// no metadata attached. This can be very slow.
    ///
    /// If `subifd` is -1 (the default), the main image is selected for each page.
    /// If it is 0 or greater and there is a SUBIFD tag, the indexed SUBIFD is
    /// selected. This can be used to read lower resolution layers from
    /// bioformats-style image pyramids.
    ///
    /// Any ICC profile is read and attached to the VIPS image as
    /// `VIPS_META_ICC_NAME`. Any XMP metadata is read and attached to the image
    /// as `VIPS_META_XMP_NAME`. Any IPTC is attached as `VIPS_META_IPTC_NAME`. The
    /// image description is
    /// attached as `VIPS_META_IMAGEDESCRIPTION`. Data in the photoshop tag is
    /// attached as `VIPS_META_PHOTOSHOP_NAME`.
    ///
    /// See also: vips_image_new_from_file(), vips_autorot().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffload(filename: String, page: Int? = nil, subifd: Int? = nil, n: Int? = nil, autorotate: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let autorotate = autorotate {
                opt.set("autorotate", value: autorotate)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tiffload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `n`: %gint, load this many pages
    /// * `autorotate`: %gboolean, use orientation tag to rotate the image
    ///   during load
    /// * `subifd`: %gint, select this subifd index
    ///
    /// Read a TIFF-formatted memory block into a VIPS image. Exactly as
    /// vips_tiffload(), but read from a memory source.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// See also: vips_tiffload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func tiffload(buffer: some Collection<UInt8>, page: Int? = nil, subifd: Int? = nil, n: Int? = nil, autorotate: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let subifd = subifd {
                    opt.set("subifd", value: subifd)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let autorotate = autorotate {
                    opt.set("autorotate", value: autorotate)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("tiffload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try tiffload(buffer: Array(buffer), page: page, subifd: subifd, n: n, autorotate: autorotate, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, load this page
    /// * `n`: %gint, load this many pages
    /// * `autorotate`: %gboolean, use orientation tag to rotate the image
    ///   during load
    /// * `subifd`: %gint, select this subifd index
    ///
    /// Exactly as vips_tiffload(), but read from a source.
    ///
    /// See also: vips_tiffload().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffload(source: VIPSSource, page: Int? = nil, subifd: Int? = nil, n: Int? = nil, autorotate: Bool? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let autorotate = autorotate {
                opt.set("autorotate", value: autorotate)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tiffload_source", options: &opt)
        }
    }

    /// Save image to tiff file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(filename: String, compression: VipsForeignTiffCompression? = nil, Q: Int? = nil, predictor: VipsForeignTiffPredictor? = nil, tile: Bool? = nil, tileWidth: Int? = nil, tileHeight: Int? = nil, pyramid: Bool? = nil, miniswhite: Bool? = nil, bitdepth: Int? = nil, resunit: VipsForeignTiffResunit? = nil, xres: Double? = nil, yres: Double? = nil, bigtiff: Bool? = nil, properties: Bool? = nil, regionShrink: VipsRegionShrink? = nil, level: Int? = nil, lossless: Bool? = nil, depth: VipsForeignDzDepth? = nil, subifd: Bool? = nil, premultiply: Bool? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if let tile = tile {
                opt.set("tile", value: tile)
            }
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let pyramid = pyramid {
                opt.set("pyramid", value: pyramid)
            }
            if let miniswhite = miniswhite {
                opt.set("miniswhite", value: miniswhite)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if let xres = xres {
                opt.set("xres", value: xres)
            }
            if let yres = yres {
                opt.set("yres", value: yres)
            }
            if let bigtiff = bigtiff {
                opt.set("bigtiff", value: bigtiff)
            }
            if let properties = properties {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let level = level {
                opt.set("level", value: level)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let premultiply = premultiply {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("tiffsave", options: &opt)
    }

    /// Save image to tiff buffer
    ///
    /// - Parameters:
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(compression: VipsForeignTiffCompression? = nil, Q: Int? = nil, predictor: VipsForeignTiffPredictor? = nil, tile: Bool? = nil, tileWidth: Int? = nil, tileHeight: Int? = nil, pyramid: Bool? = nil, miniswhite: Bool? = nil, bitdepth: Int? = nil, resunit: VipsForeignTiffResunit? = nil, xres: Double? = nil, yres: Double? = nil, bigtiff: Bool? = nil, properties: Bool? = nil, regionShrink: VipsRegionShrink? = nil, level: Int? = nil, lossless: Bool? = nil, depth: VipsForeignDzDepth? = nil, subifd: Bool? = nil, premultiply: Bool? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if let tile = tile {
                opt.set("tile", value: tile)
            }
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let pyramid = pyramid {
                opt.set("pyramid", value: pyramid)
            }
            if let miniswhite = miniswhite {
                opt.set("miniswhite", value: miniswhite)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if let xres = xres {
                opt.set("xres", value: xres)
            }
            if let yres = yres {
                opt.set("yres", value: yres)
            }
            if let bigtiff = bigtiff {
                opt.set("bigtiff", value: bigtiff)
            }
            if let properties = properties {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let level = level {
                opt.set("level", value: level)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let premultiply = premultiply {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("tiffsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from tiffsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to tiff target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(target: VIPSTarget, compression: VipsForeignTiffCompression? = nil, Q: Int? = nil, predictor: VipsForeignTiffPredictor? = nil, tile: Bool? = nil, tileWidth: Int? = nil, tileHeight: Int? = nil, pyramid: Bool? = nil, miniswhite: Bool? = nil, bitdepth: Int? = nil, resunit: VipsForeignTiffResunit? = nil, xres: Double? = nil, yres: Double? = nil, bigtiff: Bool? = nil, properties: Bool? = nil, regionShrink: VipsRegionShrink? = nil, level: Int? = nil, lossless: Bool? = nil, depth: VipsForeignDzDepth? = nil, subifd: Bool? = nil, premultiply: Bool? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if let tile = tile {
                opt.set("tile", value: tile)
            }
            if let tileWidth = tileWidth {
                opt.set("tile_width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let pyramid = pyramid {
                opt.set("pyramid", value: pyramid)
            }
            if let miniswhite = miniswhite {
                opt.set("miniswhite", value: miniswhite)
            }
            if let bitdepth = bitdepth {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if let xres = xres {
                opt.set("xres", value: xres)
            }
            if let yres = yres {
                opt.set("yres", value: yres)
            }
            if let bigtiff = bigtiff {
                opt.set("bigtiff", value: bigtiff)
            }
            if let properties = properties {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if let level = level {
                opt.set("level", value: level)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let premultiply = premultiply {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("tiffsave_target", options: &opt)
    }

}

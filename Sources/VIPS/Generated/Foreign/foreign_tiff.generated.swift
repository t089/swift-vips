//
//  foreign_tiff.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Load tiff from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffload(filename: String, page: Int = 0, subifd: Int = 0, n: Int = 0, autorotate: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if page != 0 {
                opt.set("page", value: page)
            }
            if subifd != 0 {
                opt.set("subifd", value: subifd)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tiffload", options: &opt)
        }
    }

    /// Load tiff from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffloadBuffer(buffer: Data, page: Int = 0, subifd: Int = 0, n: Int = 0, autorotate: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if page != 0 {
                opt.set("page", value: page)
            }
            if subifd != 0 {
                opt.set("subifd", value: subifd)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tiffload_buffer", options: &opt)
        }
    }

    /// Load tiff from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - subifd: Subifd index
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffloadSource(source: VIPSSource, page: Int = 0, subifd: Int = 0, n: Int = 0, autorotate: Bool = false, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if page != 0 {
                opt.set("page", value: page)
            }
            if subifd != 0 {
                opt.set("subifd", value: subifd)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if autorotate != false {
                opt.set("autorotate", value: autorotate)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tiffload_source", options: &opt)
        }
    }

    /// Save image to tiff file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: ZSTD compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(filename: String, compression: VipsForeignTiffCompression? = nil, Q: Int = 0, predictor: VipsForeignTiffPredictor? = nil, tile: Bool = false, tileWidth: Int = 0, tileHeight: Int = 0, pyramid: Bool = false, miniswhite: Bool = false, bitdepth: Int = 0, resunit: VipsForeignTiffResunit? = nil, xres: Double = 0.0, yres: Double = 0.0, bigtiff: Bool = false, properties: Bool = false, regionShrink: VipsRegionShrink? = nil, level: Int = 0, lossless: Bool = false, depth: VipsForeignDzDepth? = nil, subifd: Bool = false, premultiply: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if tile != false {
                opt.set("tile", value: tile)
            }
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if pyramid != false {
                opt.set("pyramid", value: pyramid)
            }
            if miniswhite != false {
                opt.set("miniswhite", value: miniswhite)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if xres != 0.0 {
                opt.set("xres", value: xres)
            }
            if yres != 0.0 {
                opt.set("yres", value: yres)
            }
            if bigtiff != false {
                opt.set("bigtiff", value: bigtiff)
            }
            if properties != false {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if level != 0 {
                opt.set("level", value: level)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if subifd != false {
                opt.set("subifd", value: subifd)
            }
            if premultiply != false {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("tiffsave", options: &opt)
    }

    /// Save image to tiff buffer
    ///
    /// - Parameters:
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: ZSTD compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsaveBuffer(compression: VipsForeignTiffCompression? = nil, Q: Int = 0, predictor: VipsForeignTiffPredictor? = nil, tile: Bool = false, tileWidth: Int = 0, tileHeight: Int = 0, pyramid: Bool = false, miniswhite: Bool = false, bitdepth: Int = 0, resunit: VipsForeignTiffResunit? = nil, xres: Double = 0.0, yres: Double = 0.0, bigtiff: Bool = false, properties: Bool = false, regionShrink: VipsRegionShrink? = nil, level: Int = 0, lossless: Bool = false, depth: VipsForeignDzDepth? = nil, subifd: Bool = false, premultiply: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if tile != false {
                opt.set("tile", value: tile)
            }
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if pyramid != false {
                opt.set("pyramid", value: pyramid)
            }
            if miniswhite != false {
                opt.set("miniswhite", value: miniswhite)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if xres != 0.0 {
                opt.set("xres", value: xres)
            }
            if yres != 0.0 {
                opt.set("yres", value: yres)
            }
            if bigtiff != false {
                opt.set("bigtiff", value: bigtiff)
            }
            if properties != false {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if level != 0 {
                opt.set("level", value: level)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if subifd != false {
                opt.set("subifd", value: subifd)
            }
            if premultiply != false {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("tiffsave_buffer", options: &opt)
    }

    /// Save image to tiff target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - compression: Compression for this file
    ///   - Q: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: ZSTD compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsaveTarget(target: VIPSTarget, compression: VipsForeignTiffCompression? = nil, Q: Int = 0, predictor: VipsForeignTiffPredictor? = nil, tile: Bool = false, tileWidth: Int = 0, tileHeight: Int = 0, pyramid: Bool = false, miniswhite: Bool = false, bitdepth: Int = 0, resunit: VipsForeignTiffResunit? = nil, xres: Double = 0.0, yres: Double = 0.0, bigtiff: Bool = false, properties: Bool = false, regionShrink: VipsRegionShrink? = nil, level: Int = 0, lossless: Bool = false, depth: VipsForeignDzDepth? = nil, subifd: Bool = false, premultiply: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if let compression = compression {
                opt.set("compression", value: compression)
            }
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if let predictor = predictor {
                opt.set("predictor", value: predictor)
            }
            if tile != false {
                opt.set("tile", value: tile)
            }
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if pyramid != false {
                opt.set("pyramid", value: pyramid)
            }
            if miniswhite != false {
                opt.set("miniswhite", value: miniswhite)
            }
            if bitdepth != 0 {
                opt.set("bitdepth", value: bitdepth)
            }
            if let resunit = resunit {
                opt.set("resunit", value: resunit)
            }
            if xres != 0.0 {
                opt.set("xres", value: xres)
            }
            if yres != 0.0 {
                opt.set("yres", value: yres)
            }
            if bigtiff != false {
                opt.set("bigtiff", value: bigtiff)
            }
            if properties != false {
                opt.set("properties", value: properties)
            }
            if let regionShrink = regionShrink {
                opt.set("region_shrink", value: regionShrink)
            }
            if level != 0 {
                opt.set("level", value: level)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            if subifd != false {
                opt.set("subifd", value: subifd)
            }
            if premultiply != false {
                opt.set("premultiply", value: premultiply)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("tiffsave_target", options: &opt)
    }

}

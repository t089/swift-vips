//
//  foreign_tiff.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Save image to tiff file
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - compression: Compression for this file
    ///   - quality: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(
        filename: String,
        compression: VipsForeignTiffCompression? = nil,
        quality: Int? = nil,
        predictor: VipsForeignTiffPredictor? = nil,
        tile: Bool? = nil,
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        pyramid: Bool? = nil,
        miniswhite: Bool? = nil,
        bitdepth: Int? = nil,
        resunit: VipsForeignTiffResunit? = nil,
        xres: Double? = nil,
        yres: Double? = nil,
        bigtiff: Bool? = nil,
        properties: Bool? = nil,
        regionShrink: VipsRegionShrink? = nil,
        level: Int? = nil,
        lossless: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        subifd: Bool? = nil,
        premultiply: Bool? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("filename", value: filename)
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let predictor = predictor {
            opt.set("predictor", value: predictor)
        }
        if let tile = tile {
            opt.set("tile", value: tile)
        }
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let pyramid = pyramid {
            opt.set("pyramid", value: pyramid)
        }
        if let miniswhite = miniswhite {
            opt.set("miniswhite", value: miniswhite)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let resunit = resunit {
            opt.set("resunit", value: resunit)
        }
        if let xres = xres {
            opt.set("xres", value: xres)
        }
        if let yres = yres {
            opt.set("yres", value: yres)
        }
        if let bigtiff = bigtiff {
            opt.set("bigtiff", value: bigtiff)
        }
        if let properties = properties {
            opt.set("properties", value: properties)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let level = level {
            opt.set("level", value: level)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let subifd = subifd {
            opt.set("subifd", value: subifd)
        }
        if let premultiply = premultiply {
            opt.set("premultiply", value: premultiply)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("tiffsave", options: &opt)
    }

    /// Save image to tiff buffer
    ///
    /// - Parameters:
    ///   - compression: Compression for this file
    ///   - quality: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(
        compression: VipsForeignTiffCompression? = nil,
        quality: Int? = nil,
        predictor: VipsForeignTiffPredictor? = nil,
        tile: Bool? = nil,
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        pyramid: Bool? = nil,
        miniswhite: Bool? = nil,
        bitdepth: Int? = nil,
        resunit: VipsForeignTiffResunit? = nil,
        xres: Double? = nil,
        yres: Double? = nil,
        bigtiff: Bool? = nil,
        properties: Bool? = nil,
        regionShrink: VipsRegionShrink? = nil,
        level: Int? = nil,
        lossless: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        subifd: Bool? = nil,
        premultiply: Bool? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws -> VIPSBlob {
        var opt = VIPSOption()

        let out: UnsafeMutablePointer<UnsafeMutablePointer<VipsBlob>?> = .allocate(capacity: 1)
        out.initialize(to: nil)
        defer {
            out.deallocate()
        }

        opt.set("in", value: self.image)
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let predictor = predictor {
            opt.set("predictor", value: predictor)
        }
        if let tile = tile {
            opt.set("tile", value: tile)
        }
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let pyramid = pyramid {
            opt.set("pyramid", value: pyramid)
        }
        if let miniswhite = miniswhite {
            opt.set("miniswhite", value: miniswhite)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let resunit = resunit {
            opt.set("resunit", value: resunit)
        }
        if let xres = xres {
            opt.set("xres", value: xres)
        }
        if let yres = yres {
            opt.set("yres", value: yres)
        }
        if let bigtiff = bigtiff {
            opt.set("bigtiff", value: bigtiff)
        }
        if let properties = properties {
            opt.set("properties", value: properties)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let level = level {
            opt.set("level", value: level)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let subifd = subifd {
            opt.set("subifd", value: subifd)
        }
        if let premultiply = premultiply {
            opt.set("premultiply", value: premultiply)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }
        opt.set("buffer", value: out)

        try Self.call("tiffsave_buffer", options: &opt)

        guard let vipsBlob = out.pointee else {
            throw VIPSError("Failed to get buffer from tiffsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to tiff target
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - compression: Compression for this file
    ///   - quality: Q factor
    ///   - predictor: Compression prediction
    ///   - tile: Write a tiled tiff
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - pyramid: Write a pyramidal tiff
    ///   - miniswhite: Use 0 for white in 1-bit images
    ///   - bitdepth: Write as a 1, 2, 4 or 8 bit image
    ///   - resunit: Resolution unit
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - bigtiff: Write a bigtiff image
    ///   - properties: Write a properties document to IMAGEDESCRIPTION
    ///   - regionShrink: Method to shrink regions
    ///   - level: Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level
    ///   - lossless: Enable WEBP lossless mode
    ///   - depth: Pyramid depth
    ///   - subifd: Save pyr layers as sub-IFDs
    ///   - premultiply: Save with premultiplied alpha
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func tiffsave(
        target: VIPSTarget,
        compression: VipsForeignTiffCompression? = nil,
        quality: Int? = nil,
        predictor: VipsForeignTiffPredictor? = nil,
        tile: Bool? = nil,
        tileWidth: Int? = nil,
        tileHeight: Int? = nil,
        pyramid: Bool? = nil,
        miniswhite: Bool? = nil,
        bitdepth: Int? = nil,
        resunit: VipsForeignTiffResunit? = nil,
        xres: Double? = nil,
        yres: Double? = nil,
        bigtiff: Bool? = nil,
        properties: Bool? = nil,
        regionShrink: VipsRegionShrink? = nil,
        level: Int? = nil,
        lossless: Bool? = nil,
        depth: VipsForeignDzDepth? = nil,
        subifd: Bool? = nil,
        premultiply: Bool? = nil,
        keep: VipsForeignKeep? = nil,
        background: [Double]? = nil,
        pageHeight: Int? = nil,
        profile: String? = nil
    ) throws {
        var opt = VIPSOption()

        opt.set("in", value: self)
        opt.set("target", value: target)
        if let compression = compression {
            opt.set("compression", value: compression)
        }
        if let quality = quality {
            opt.set("Q", value: quality)
        }
        if let predictor = predictor {
            opt.set("predictor", value: predictor)
        }
        if let tile = tile {
            opt.set("tile", value: tile)
        }
        if let tileWidth = tileWidth {
            opt.set("tile_width", value: tileWidth)
        }
        if let tileHeight = tileHeight {
            opt.set("tile_height", value: tileHeight)
        }
        if let pyramid = pyramid {
            opt.set("pyramid", value: pyramid)
        }
        if let miniswhite = miniswhite {
            opt.set("miniswhite", value: miniswhite)
        }
        if let bitdepth = bitdepth {
            opt.set("bitdepth", value: bitdepth)
        }
        if let resunit = resunit {
            opt.set("resunit", value: resunit)
        }
        if let xres = xres {
            opt.set("xres", value: xres)
        }
        if let yres = yres {
            opt.set("yres", value: yres)
        }
        if let bigtiff = bigtiff {
            opt.set("bigtiff", value: bigtiff)
        }
        if let properties = properties {
            opt.set("properties", value: properties)
        }
        if let regionShrink = regionShrink {
            opt.set("region_shrink", value: regionShrink)
        }
        if let level = level {
            opt.set("level", value: level)
        }
        if let lossless = lossless {
            opt.set("lossless", value: lossless)
        }
        if let depth = depth {
            opt.set("depth", value: depth)
        }
        if let subifd = subifd {
            opt.set("subifd", value: subifd)
        }
        if let premultiply = premultiply {
            opt.set("premultiply", value: premultiply)
        }
        if let keep = keep {
            opt.set("keep", value: keep)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let pageHeight = pageHeight {
            opt.set("page_height", value: pageHeight)
        }
        if let profile = profile {
            opt.set("profile", value: profile)
        }

        try Self.call("tiffsave_target", options: &opt)
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Load tiff from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - subifd: Subifd index
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffload(
        filename: String,
        page: Int? = nil,
        n: Int? = nil,
        autorotate: Bool? = nil,
        subifd: Int? = nil,
        unlimited: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let autorotate = autorotate {
                opt.set("autorotate", value: autorotate)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let unlimited = unlimited {
                opt.set("unlimited", value: unlimited)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("tiffload", options: &opt)
        }
    }

    /// Load tiff from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - subifd: Subifd index
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func tiffload(
        buffer: VIPSBlob,
        page: Int? = nil,
        n: Int? = nil,
        autorotate: Bool? = nil,
        subifd: Int? = nil,
        unlimited: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        // the operation will retain the blob
        try buffer.withVipsBlob { blob in
            try Self { out in
                var opt = VIPSOption()

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let autorotate = autorotate {
                    opt.set("autorotate", value: autorotate)
                }
                if let subifd = subifd {
                    opt.set("subifd", value: subifd)
                }
                if let unlimited = unlimited {
                    opt.set("unlimited", value: unlimited)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try Self.call("tiffload_buffer", options: &opt)
            }
        }
    }

    /// Load tiff from buffer without copying the data. The caller must ensure the buffer remains valid for
    /// the lifetime of the returned image and all its descendants.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - subifd: Subifd index
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func tiffload(
        unsafeBuffer buffer: UnsafeRawBufferPointer,
        page: Int? = nil,
        n: Int? = nil,
        autorotate: Bool? = nil,
        subifd: Int? = nil,
        unlimited: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        let blob = VIPSBlob(noCopy: buffer)
        return try tiffload(
            buffer: blob,
            page: page,
            n: n,
            autorotate: autorotate,
            subifd: subifd,
            unlimited: unlimited,
            memory: memory,
            access: access,
            failOn: failOn,
            revalidate: revalidate
        )
    }

    /// Load tiff from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - autorotate: Rotate image using orientation tag
    ///   - subifd: Subifd index
    ///   - unlimited: Remove all denial of service limits
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func tiffload(
        source: VIPSSource,
        page: Int? = nil,
        n: Int? = nil,
        autorotate: Bool? = nil,
        subifd: Int? = nil,
        unlimited: Bool? = nil,
        memory: Bool? = nil,
        access: VipsAccess? = nil,
        failOn: VipsFailOn? = nil,
        revalidate: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let autorotate = autorotate {
                opt.set("autorotate", value: autorotate)
            }
            if let subifd = subifd {
                opt.set("subifd", value: subifd)
            }
            if let unlimited = unlimited {
                opt.set("unlimited", value: unlimited)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try Self.call("tiffload_source", options: &opt)
        }
    }

}

//
//  foreign_webp.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImage {

    /// Optional arguments:
    ///
    /// * `page`: %gint, page (frame) to read
    /// * `n`: %gint, load this many pages
    /// * `scale`: %gdouble, scale by this much on load
    ///
    /// Read a WebP file into a VIPS image.
    ///
    /// Use `page` to select a page to render, numbering from zero.
    ///
    /// Use `n` to select the number of pages to render. The default is 1. Pages are
    /// rendered in a vertical column, with each individual page aligned to the
    /// left. Set to -1 to mean "until the end of the document". Use vips_grid()
    /// to change page layout.
    ///
    /// Use `scale` to specify a scale-on-load factor. For example, 2.0 to double
    /// the size on load. Animated webp images don't support shrink-on-load, so a
    /// further resize may be necessary.
    ///
    /// The loader supports ICC, EXIF and XMP metadata.
    ///
    /// See also: vips_image_new_from_file().
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func webpload(filename: String, page: Int? = nil, n: Int? = nil, scale: Double? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let scale = scale {
                opt.set("scale", value: scale)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("webpload", options: &opt)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, page (frame) to read
    /// * `n`: %gint, load this many pages
    /// * `scale`: %gdouble, scale by this much on load
    ///
    /// Read a WebP-formatted memory block into a VIPS image. Exactly as
    /// vips_webpload(), but read from a memory buffer.
    ///
    /// You must not free the buffer while `out` is active. The
    /// `VipsObject`::postclose signal on `out` is a good place to free.
    ///
    /// See also: vips_webpload()
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    @inlinable
    public static func webpload(buffer: some Collection<UInt8>, page: Int? = nil, n: Int? = nil, scale: Double? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        let maybeImage = try buffer.withContiguousStorageIfAvailable { buffer in
            return try VIPSImage(nil) { out in
                var opt = VIPSOption()

                let blob = vips_blob_new(nil, buffer.baseAddress, buffer.count)
                defer { vips_area_unref(shim_vips_area(blob)) }

                opt.set("buffer", value: blob)
                if let page = page {
                    opt.set("page", value: page)
                }
                if let n = n {
                    opt.set("n", value: n)
                }
                if let scale = scale {
                    opt.set("scale", value: scale)
                }
                if let memory = memory {
                    opt.set("memory", value: memory)
                }
                if let access = access {
                    opt.set("access", value: access)
                }
                if let failOn = failOn {
                    opt.set("fail_on", value: failOn)
                }
                if let revalidate = revalidate {
                    opt.set("revalidate", value: revalidate)
                }
                opt.set("out", value: &out)

                try VIPSImage.call("webpload_buffer", options: &opt)
            }
        }
        if let maybeImage {
            return maybeImage
        } else {
            return try webpload(buffer: Array(buffer), page: page, n: n, scale: scale, memory: memory, access: access, failOn: failOn, revalidate: revalidate)
        }
    }

    /// Optional arguments:
    ///
    /// * `page`: %gint, page (frame) to read
    /// * `n`: %gint, load this many pages
    /// * `scale`: %gdouble, scale by this much on load
    ///
    /// Exactly as vips_webpload(), but read from a source.
    ///
    /// See also: vips_webpload()
    ///
    /// Returns: 0 on success, -1 on error.
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func webpload(source: VIPSSource, page: Int? = nil, n: Int? = nil, scale: Double? = nil, memory: Bool? = nil, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([source]) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if let page = page {
                opt.set("page", value: page)
            }
            if let n = n {
                opt.set("n", value: n)
            }
            if let scale = scale {
                opt.set("scale", value: scale)
            }
            if let memory = memory {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if let revalidate = revalidate {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("webpload_source", options: &opt)
        }
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - targetSize: Desired target size in bytes
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - smartDeblock: Enable auto-adjusting of the deblocking filter
    ///   - passes: Number of entropy-analysis passes (in [1..10])
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsave(filename: String, Q: Int? = nil, lossless: Bool? = nil, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool? = nil, nearLossless: Bool? = nil, alphaQ: Int? = nil, minSize: Bool? = nil, kmin: Int? = nil, kmax: Int? = nil, effort: Int? = nil, targetSize: Int? = nil, mixed: Bool? = nil, smartDeblock: Bool? = nil, passes: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("filename", value: filename)
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if let smartSubsample = smartSubsample {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if let nearLossless = nearLossless {
                opt.set("near_lossless", value: nearLossless)
            }
            if let alphaQ = alphaQ {
                opt.set("alpha_q", value: alphaQ)
            }
            if let minSize = minSize {
                opt.set("min_size", value: minSize)
            }
            if let kmin = kmin {
                opt.set("kmin", value: kmin)
            }
            if let kmax = kmax {
                opt.set("kmax", value: kmax)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let targetSize = targetSize {
                opt.set("target_size", value: targetSize)
            }
            if let mixed = mixed {
                opt.set("mixed", value: mixed)
            }
            if let smartDeblock = smartDeblock {
                opt.set("smart_deblock", value: smartDeblock)
            }
            if let passes = passes {
                opt.set("passes", value: passes)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave", options: &opt)
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - targetSize: Desired target size in bytes
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - smartDeblock: Enable auto-adjusting of the deblocking filter
    ///   - passes: Number of entropy-analysis passes (in [1..10])
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsave(Q: Int? = nil, lossless: Bool? = nil, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool? = nil, nearLossless: Bool? = nil, alphaQ: Int? = nil, minSize: Bool? = nil, kmin: Int? = nil, kmax: Int? = nil, effort: Int? = nil, targetSize: Int? = nil, mixed: Bool? = nil, smartDeblock: Bool? = nil, passes: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws -> VIPSBlob {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsBlob>! = nil

            opt.set("in", value: self.image)
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if let smartSubsample = smartSubsample {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if let nearLossless = nearLossless {
                opt.set("near_lossless", value: nearLossless)
            }
            if let alphaQ = alphaQ {
                opt.set("alpha_q", value: alphaQ)
            }
            if let minSize = minSize {
                opt.set("min_size", value: minSize)
            }
            if let kmin = kmin {
                opt.set("kmin", value: kmin)
            }
            if let kmax = kmax {
                opt.set("kmax", value: kmax)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let targetSize = targetSize {
                opt.set("target_size", value: targetSize)
            }
            if let mixed = mixed {
                opt.set("mixed", value: mixed)
            }
            if let smartDeblock = smartDeblock {
                opt.set("smart_deblock", value: smartDeblock)
            }
            if let passes = passes {
                opt.set("passes", value: passes)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }
            opt.set("buffer", value: &out)

            try VIPSImage.call("webpsave_buffer", options: &opt)

        guard let vipsBlob = out else {
            throw VIPSError("Failed to get buffer from webpsave_buffer")
        }

        return VIPSBlob(vipsBlob)
    }

    /// Save image to webp mime
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - targetSize: Desired target size in bytes
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - smartDeblock: Enable auto-adjusting of the deblocking filter
    ///   - passes: Number of entropy-analysis passes (in [1..10])
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsave(Q: Int? = nil, lossless: Bool? = nil, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool? = nil, nearLossless: Bool? = nil, alphaQ: Int? = nil, minSize: Bool? = nil, kmin: Int? = nil, kmax: Int? = nil, effort: Int? = nil, targetSize: Int? = nil, mixed: Bool? = nil, smartDeblock: Bool? = nil, passes: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if let smartSubsample = smartSubsample {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if let nearLossless = nearLossless {
                opt.set("near_lossless", value: nearLossless)
            }
            if let alphaQ = alphaQ {
                opt.set("alpha_q", value: alphaQ)
            }
            if let minSize = minSize {
                opt.set("min_size", value: minSize)
            }
            if let kmin = kmin {
                opt.set("kmin", value: kmin)
            }
            if let kmax = kmax {
                opt.set("kmax", value: kmax)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let targetSize = targetSize {
                opt.set("target_size", value: targetSize)
            }
            if let mixed = mixed {
                opt.set("mixed", value: mixed)
            }
            if let smartDeblock = smartDeblock {
                opt.set("smart_deblock", value: smartDeblock)
            }
            if let passes = passes {
                opt.set("passes", value: passes)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave_mime", options: &opt)
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - targetSize: Desired target size in bytes
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - smartDeblock: Enable auto-adjusting of the deblocking filter
    ///   - passes: Number of entropy-analysis passes (in [1..10])
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsave(target: VIPSTarget, Q: Int? = nil, lossless: Bool? = nil, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool? = nil, nearLossless: Bool? = nil, alphaQ: Int? = nil, minSize: Bool? = nil, kmin: Int? = nil, kmax: Int? = nil, effort: Int? = nil, targetSize: Int? = nil, mixed: Bool? = nil, smartDeblock: Bool? = nil, passes: Int? = nil, keep: VipsForeignKeep? = nil, background: [Double]? = nil, pageHeight: Int? = nil, profile: String? = nil) throws {
        var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("target", value: target)
            if let Q = Q {
                opt.set("Q", value: Q)
            }
            if let lossless = lossless {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if let smartSubsample = smartSubsample {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if let nearLossless = nearLossless {
                opt.set("near_lossless", value: nearLossless)
            }
            if let alphaQ = alphaQ {
                opt.set("alpha_q", value: alphaQ)
            }
            if let minSize = minSize {
                opt.set("min_size", value: minSize)
            }
            if let kmin = kmin {
                opt.set("kmin", value: kmin)
            }
            if let kmax = kmax {
                opt.set("kmax", value: kmax)
            }
            if let effort = effort {
                opt.set("effort", value: effort)
            }
            if let targetSize = targetSize {
                opt.set("target_size", value: targetSize)
            }
            if let mixed = mixed {
                opt.set("mixed", value: mixed)
            }
            if let smartDeblock = smartDeblock {
                opt.set("smart_deblock", value: smartDeblock)
            }
            if let passes = passes {
                opt.set("passes", value: passes)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let pageHeight = pageHeight {
                opt.set("page_height", value: pageHeight)
            }
            if let profile = profile {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave_target", options: &opt)
    }

}

//
//  foreign_webp.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Load webp from file
    ///
    /// - Parameters:
    ///   - filename: Filename to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func webpload(filename: String, page: Int = 0, n: Int = 0, scale: Double = 0.0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("filename", value: filename)
            if page != 0 {
                opt.set("page", value: page)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if scale != 0.0 {
                opt.set("scale", value: scale)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("webpload", options: &opt)
        }
    }

    /// Load webp from buffer
    ///
    /// - Parameters:
    ///   - buffer: Buffer to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func webploadBuffer(buffer: Data, page: Int = 0, n: Int = 0, scale: Double = 0.0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("buffer", value: buffer)
            if page != 0 {
                opt.set("page", value: page)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if scale != 0.0 {
                opt.set("scale", value: scale)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("webpload_buffer", options: &opt)
        }
    }

    /// Load webp from source
    ///
    /// - Parameters:
    ///   - source: Source to load from
    ///   - page: First page to load
    ///   - n: Number of pages to load, -1 for all
    ///   - scale: Factor to scale by
    ///   - memory: Force open via memory
    ///   - access: Required access pattern for this file
    ///   - failOn: Error level to fail on
    ///   - revalidate: Don't use a cached result for this operation
    public static func webploadSource(source: VIPSSource, page: Int = 0, n: Int = 0, scale: Double = 0.0, memory: Bool = false, access: VipsAccess? = nil, failOn: VipsFailOn? = nil, revalidate: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("source", value: source)
            if page != 0 {
                opt.set("page", value: page)
            }
            if n != 0 {
                opt.set("n", value: n)
            }
            if scale != 0.0 {
                opt.set("scale", value: scale)
            }
            if memory != false {
                opt.set("memory", value: memory)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let failOn = failOn {
                opt.set("fail_on", value: failOn)
            }
            if revalidate != false {
                opt.set("revalidate", value: revalidate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("webpload_source", options: &opt)
        }
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - filename: Filename to save to
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsave(filename: String, Q: Int = 0, lossless: Bool = false, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool = false, nearLossless: Bool = false, alphaQ: Int = 0, minSize: Bool = false, kmin: Int = 0, kmax: Int = 0, effort: Int = 0, mixed: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("filename", value: filename)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if smartSubsample != false {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if nearLossless != false {
                opt.set("near_lossless", value: nearLossless)
            }
            if alphaQ != 0 {
                opt.set("alpha_q", value: alphaQ)
            }
            if minSize != false {
                opt.set("min_size", value: minSize)
            }
            if kmin != 0 {
                opt.set("kmin", value: kmin)
            }
            if kmax != 0 {
                opt.set("kmax", value: kmax)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if mixed != false {
                opt.set("mixed", value: mixed)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave", options: &opt)
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsaveBuffer(Q: Int = 0, lossless: Bool = false, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool = false, nearLossless: Bool = false, alphaQ: Int = 0, minSize: Bool = false, kmin: Int = 0, kmax: Int = 0, effort: Int = 0, mixed: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws -> Data {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if smartSubsample != false {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if nearLossless != false {
                opt.set("near_lossless", value: nearLossless)
            }
            if alphaQ != 0 {
                opt.set("alpha_q", value: alphaQ)
            }
            if minSize != false {
                opt.set("min_size", value: minSize)
            }
            if kmin != 0 {
                opt.set("kmin", value: kmin)
            }
            if kmax != 0 {
                opt.set("kmax", value: kmax)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if mixed != false {
                opt.set("mixed", value: mixed)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave_buffer", options: &opt)
    }

    /// Save image to webp mime
    ///
    /// - Parameters:
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsaveMime(Q: Int = 0, lossless: Bool = false, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool = false, nearLossless: Bool = false, alphaQ: Int = 0, minSize: Bool = false, kmin: Int = 0, kmax: Int = 0, effort: Int = 0, mixed: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if smartSubsample != false {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if nearLossless != false {
                opt.set("near_lossless", value: nearLossless)
            }
            if alphaQ != 0 {
                opt.set("alpha_q", value: alphaQ)
            }
            if minSize != false {
                opt.set("min_size", value: minSize)
            }
            if kmin != 0 {
                opt.set("kmin", value: kmin)
            }
            if kmax != 0 {
                opt.set("kmax", value: kmax)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if mixed != false {
                opt.set("mixed", value: mixed)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave_mime", options: &opt)
    }

    /// Save as webp
    ///
    /// - Parameters:
    ///   - target: Target to save to
    ///   - Q: Q factor
    ///   - lossless: Enable lossless compression
    ///   - preset: Preset for lossy compression
    ///   - smartSubsample: Enable high quality chroma subsampling
    ///   - nearLossless: Enable preprocessing in lossless mode (uses Q)
    ///   - alphaQ: Change alpha plane fidelity for lossy compression
    ///   - minSize: Optimise for minimum size
    ///   - kmin: Minimum number of frames between key frames
    ///   - kmax: Maximum number of frames between key frames
    ///   - effort: Level of CPU effort to reduce file size
    ///   - mixed: Allow mixed encoding (might reduce file size)
    ///   - keep: Which metadata to retain
    ///   - background: Background value
    ///   - pageHeight: Set page height for multipage save
    ///   - profile: Filename of ICC profile to embed
    public func webpsaveTarget(target: VIPSTarget, Q: Int = 0, lossless: Bool = false, preset: VipsForeignWebpPreset? = nil, smartSubsample: Bool = false, nearLossless: Bool = false, alphaQ: Int = 0, minSize: Bool = false, kmin: Int = 0, kmax: Int = 0, effort: Int = 0, mixed: Bool = false, keep: VipsForeignKeep? = nil, background: [Double] = [], pageHeight: Int = 0, profile: String = "") throws {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("target", value: target)
            if Q != 0 {
                opt.set("Q", value: Q)
            }
            if lossless != false {
                opt.set("lossless", value: lossless)
            }
            if let preset = preset {
                opt.set("preset", value: preset)
            }
            if smartSubsample != false {
                opt.set("smart_subsample", value: smartSubsample)
            }
            if nearLossless != false {
                opt.set("near_lossless", value: nearLossless)
            }
            if alphaQ != 0 {
                opt.set("alpha_q", value: alphaQ)
            }
            if minSize != false {
                opt.set("min_size", value: minSize)
            }
            if kmin != 0 {
                opt.set("kmin", value: kmin)
            }
            if kmax != 0 {
                opt.set("kmax", value: kmax)
            }
            if effort != 0 {
                opt.set("effort", value: effort)
            }
            if mixed != false {
                opt.set("mixed", value: mixed)
            }
            if let keep = keep {
                opt.set("keep", value: keep)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            if profile != "" {
                opt.set("profile", value: profile)
            }

            try VIPSImage.call("webpsave_target", options: &opt)
    }

}

//
//  arithmetic.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Transform float lab to signed short
    public func Lab2LabS() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("Lab2LabS", options: &opt)
        }
    }

    /// Unpack a labq image to short lab
    public func LabQ2LabS() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("LabQ2LabS", options: &opt)
        }
    }

    /// Transform signed short lab to float
    public func LabS2Lab() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("LabS2Lab", options: &opt)
        }
    }

    /// Transform short lab to labq coding
    public func LabS2LabQ() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("LabS2LabQ", options: &opt)
        }
    }

    /// Absolute value of an image
    public func abs() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("abs", options: &opt)
        }
    }

    /// This operation calculates `in1` + `in2` and writes the result to `out`.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), then the
    /// following table is used to determine the output type:
    ///
    ///   VipsAdd type promotion
    ///
    ///         input type
    ///         output type
    ///
    ///         uchar
    ///         ushort
    ///
    ///         char
    ///         short
    ///
    ///         ushort
    ///         uint
    ///
    ///         short
    ///         int
    ///
    ///         uint
    ///         uint
    ///
    ///         int
    ///         int
    ///
    ///         float
    ///         float
    ///
    ///         double
    ///         double
    ///
    ///         complex
    ///         complex
    ///
    ///         double complex
    ///         double complex
    ///
    /// In other words, the output type is just large enough to hold the whole
    /// range of possible values.
    ///
    /// Operations on integer images are performed using the processor's vector unit,
    /// if possible. Disable this with --vips-novector or VIPS_NOVECTOR.
    ///
    /// See also: vips_subtract(), vips_linear().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func add(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("add", options: &opt)
        }
    }

    /// Append an alpha channel
    public func addalpha() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("addalpha", options: &opt)
        }
    }

    /// Find image average
    public func avg() throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("avg", options: &opt)

        return out
    }

    /// Perform various boolean operations on pairs of images.
    ///
    /// The output image is the same format as the upcast input images for integer
    /// types. Float types are cast to int before processing. Complex types are not
    /// supported.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic).
    ///
    /// See also: vips_boolean_const().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - boolean: Boolean to perform
    public func boolean(_ rhs: VIPSImage, boolean: VipsOperationBoolean) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("boolean", value: boolean)
            opt.set("out", value: &out)

            try VIPSImage.call("boolean", options: &opt)
        }
    }

    /// Boolean operations against a constant
    ///
    /// - Parameters:
    ///   - boolean: Boolean to perform
    ///   - c: Array of constants
    public func booleanConst(boolean: VipsOperationBoolean, c: [Double]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("boolean", value: boolean)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try VIPSImage.call("boolean_const", options: &opt)
        }
    }

    /// Perform a complex operation on an image
    ///
    /// - Parameters:
    ///   - cmplx: Complex to perform
    public func complex(cmplx: VipsOperationComplex) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("cmplx", value: cmplx)
            opt.set("out", value: &out)

            try VIPSImage.call("complex", options: &opt)
        }
    }

    /// Perform various binary operations on complex images.
    ///
    /// Angles are expressed in degrees. The output type is complex unless the
    /// input is double or dpcomplex, in which case the output is dpcomplex.
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - cmplx: Binary complex operation to perform
    public func complex2(_ rhs: VIPSImage, cmplx: VipsOperationComplex2) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("cmplx", value: cmplx)
            opt.set("out", value: &out)

            try VIPSImage.call("complex2", options: &opt)
        }
    }

    /// Compose two real images to make a complex image. If either `left` or `right`
    /// are `VIPS_FORMAT_DOUBLE`, `out` is `VIPS_FORMAT_DPCOMPLEX`. Otherwise `out`
    /// is `VIPS_FORMAT_COMPLEX`. `left` becomes the real component of `out` and
    /// `right` the imaginary.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// See also: vips_complexget().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func complexform(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("complexform", options: &opt)
        }
    }

    /// Get a component from a complex image
    ///
    /// - Parameters:
    ///   - `get`: Complex to perform
    public func complexget(`get`: VipsOperationComplexget) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("get", value: `get`)
            opt.set("out", value: &out)

            try VIPSImage.call("complexget", options: &opt)
        }
    }

    /// Find image standard deviation
    public func deviate() throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("deviate", options: &opt)

        return out
    }

    /// This operation calculates `in1` / `in2` and writes the result to `out`. If any
    /// pixels in `in2` are zero, the corresponding pixel in `out` is also zero.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), then the
    /// following table is used to determine the output type:
    ///
    ///   vips_divide() type promotion
    ///
    ///         input type
    ///         output type
    ///
    ///         uchar
    ///         float
    ///
    ///         char
    ///         float
    ///
    ///         ushort
    ///         float
    ///
    ///         short
    ///         float
    ///
    ///         uint
    ///         float
    ///
    ///         int
    ///         float
    ///
    ///         float
    ///         float
    ///
    ///         double
    ///         double
    ///
    ///         complex
    ///         complex
    ///
    ///         double complex
    ///         double complex
    ///
    /// In other words, the output type is just large enough to hold the whole
    /// range of possible values.
    ///
    /// See also: vips_multiply(), vips_linear(), vips_pow().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func divide(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("divide", options: &opt)
        }
    }

    /// Invert an image
    public func invert() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("invert", options: &opt)
        }
    }

    /// Build an inverted look-up table
    ///
    /// - Parameters:
    ///   - size: LUT size to generate
    public func invertlut(size: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let size = size {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("invertlut", options: &opt)
        }
    }

    /// Apply a math operation to an image
    ///
    /// - Parameters:
    ///   - math: Math to perform
    public func math(_ math: VipsOperationMath) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("math", value: math)
            opt.set("out", value: &out)

            try VIPSImage.call("math", options: &opt)
        }
    }

    /// This operation calculates a 2-ary maths operation on a pair of images
    /// and writes the result to `out`. The images may have any
    /// non-complex format. `out` is float except in the case that either of `left`
    /// or `right` are double, in which case `out` is also double.
    ///
    /// It detects division by zero, setting those pixels to zero in the output.
    /// Beware: it does this silently!
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), and that format is the
    /// result type.
    ///
    /// See also: vips_math2_const().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - math2: Math to perform
    public func math2(_ rhs: VIPSImage, math2: VipsOperationMath2) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("math2", value: math2)
            opt.set("out", value: &out)

            try VIPSImage.call("math2", options: &opt)
        }
    }

    /// Binary math operations with a constant
    ///
    /// - Parameters:
    ///   - math2: Math to perform
    ///   - c: Array of constants
    public func math2Const(math2: VipsOperationMath2, c: [Double]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("math2", value: math2)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try VIPSImage.call("math2_const", options: &opt)
        }
    }

    /// Invert an matrix
    public func matrixinvert() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("matrixinvert", options: &opt)
        }
    }

    /// Find image maximum
    ///
    /// - Parameters:
    ///   - size: Number of maximum values to find
    public func max(size: Int? = nil) throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

            opt.set("in", value: self.image)
            if let size = size {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("max", options: &opt)

        return out
    }

    /// Maximum of a pair of images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func maxpair(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("maxpair", options: &opt)
        }
    }

    /// Find image minimum
    ///
    /// - Parameters:
    ///   - size: Number of minimum values to find
    public func min(size: Int? = nil) throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

            opt.set("in", value: self.image)
            if let size = size {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("min", options: &opt)

        return out
    }

    /// Minimum of a pair of images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func minpair(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("minpair", options: &opt)
        }
    }

    /// This operation calculates `left` * `right` and writes the result to `out`.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), then the
    /// following table is used to determine the output type:
    ///
    ///   VipsMultiply type promotion
    ///
    ///         input type
    ///         output type
    ///
    ///         uchar
    ///         ushort
    ///
    ///         char
    ///         short
    ///
    ///         ushort
    ///         uint
    ///
    ///         short
    ///         int
    ///
    ///         uint
    ///         uint
    ///
    ///         int
    ///         int
    ///
    ///         float
    ///         float
    ///
    ///         double
    ///         double
    ///
    ///         complex
    ///         complex
    ///
    ///         double complex
    ///         double complex
    ///
    /// In other words, the output type is just large enough to hold the whole
    /// range of possible values.
    ///
    /// See also: vips_add(), vips_linear().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func multiply(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("multiply", options: &opt)
        }
    }

    /// Premultiply image alpha
    ///
    /// - Parameters:
    ///   - maxAlpha: Maximum value of alpha channel
    public func premultiply(maxAlpha: Double? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let maxAlpha = maxAlpha {
                opt.set("max_alpha", value: maxAlpha)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("premultiply", options: &opt)
        }
    }

    /// Perform various relational operations on pairs of images.
    ///
    /// The output type is always uchar, with 0 for FALSE and 255 for TRUE.
    ///
    /// Less-than and greater-than for complex images compare the modulus.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic).
    ///
    /// To decide if pixels match exactly, that is have the same value in every
    /// band, use vips_bandbool() after this operation to AND or OR image bands
    /// together.
    ///
    /// See also: vips_boolean(), vips_bandbool(), vips_relational_const().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - relational: Relational to perform
    public func relational(_ rhs: VIPSImage, relational: VipsOperationRelational) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("relational", value: relational)
            opt.set("out", value: &out)

            try VIPSImage.call("relational", options: &opt)
        }
    }

    /// Relational operations against a constant
    ///
    /// - Parameters:
    ///   - relational: Relational to perform
    ///   - c: Array of constants
    public func relationalConst(relational: VipsOperationRelational, c: [Double]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("relational", value: relational)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try VIPSImage.call("relational_const", options: &opt)
        }
    }

    /// This operation calculates `left` % `right` (remainder after integer division)
    /// and writes the result to `out`. The images may have any
    /// non-complex format. For float formats, vips_remainder() calculates `in1` -
    /// `in2` * floor (`in1` / `in2`).
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), and that format is the
    /// result type.
    ///
    /// See also: vips_remainder_const(), vips_divide(), vips_round().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func remainder(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("remainder", options: &opt)
        }
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func remainder(_ value: Double) throws -> VIPSImage {
        return try remainderConst(c: [value])
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func remainder(_ value: Int) throws -> VIPSImage {
        return try remainderConst(c: [Double(value)])
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - c: Array of constants
    public func remainderConst(c: [Double]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try VIPSImage.call("remainder_const", options: &opt)
        }
    }

    /// Perform a round function on an image
    ///
    /// - Parameters:
    ///   - round: Rounding operation to perform
    public func round(_ round: VipsOperationRound) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("round", value: round)
            opt.set("out", value: &out)

            try VIPSImage.call("round", options: &opt)
        }
    }

    /// Unit vector of pixel
    public func sign() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("sign", options: &opt)
        }
    }

    /// Find many image stats
    public func stats() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("stats", options: &opt)
        }
    }

    /// This operation calculates `in1` - `in2` and writes the result to `out`.
    ///
    /// If the images differ in size, the smaller image is enlarged to match the
    /// larger by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, one of the images
    /// must have one band. In this case, an n-band image is formed from the
    /// one-band image by joining n copies of the one-band image together, and then
    /// the two n-band images are operated upon.
    ///
    /// The two input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), then the
    /// following table is used to determine the output type:
    ///
    ///   VipsSubtract type promotion
    ///
    ///         input type
    ///         output type
    ///
    ///         uchar
    ///         short
    ///
    ///         char
    ///         short
    ///
    ///         ushort
    ///         int
    ///
    ///         short
    ///         int
    ///
    ///         uint
    ///         int
    ///
    ///         int
    ///         int
    ///
    ///         float
    ///         float
    ///
    ///         double
    ///         double
    ///
    ///         complex
    ///         complex
    ///
    ///         double complex
    ///         double complex
    ///
    /// In other words, the output type is just large enough to hold the whole
    /// range of possible values.
    ///
    /// See also: vips_add(), vips_linear().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func subtract(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("subtract", options: &opt)
        }
    }

    /// This operation sums all images in `in` and writes the result to `out`.
    ///
    /// If the images differ in size, the smaller images are enlarged to match the
    /// largest by adding zero pixels along the bottom and right.
    ///
    /// If the number of bands differs, all but one of the images
    /// must have one band. In this case, n-band images are formed from the
    /// one-band images by joining n copies of the one-band images together, and then
    /// the n-band images are operated upon.
    ///
    /// The input images are cast up to the smallest common format (see table
    /// Smallest common format in
    /// arithmetic), then the
    /// following table is used to determine the output type:
    ///
    ///   VipsSum type promotion
    ///
    ///         input type
    ///         output type
    ///
    ///         uchar
    ///         uint
    ///
    ///         char
    ///         int
    ///
    ///         ushort
    ///         uint
    ///
    ///         short
    ///         int
    ///
    ///         uint
    ///         uint
    ///
    ///         int
    ///         int
    ///
    ///         float
    ///         float
    ///
    ///         double
    ///         double
    ///
    ///         complex
    ///         complex
    ///
    ///         double complex
    ///         double complex
    ///
    /// In other words, the output type is just large enough to hold the whole
    /// range of possible values.
    ///
    /// See also: vips_add().
    ///
    /// Returns: 0 on success, -1 on error
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    public static func sum(_ `in`: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage([`in`]) { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("out", value: &out)

            try VIPSImage.call("sum", options: &opt)
        }
    }

    /// Unpremultiply image alpha
    ///
    /// - Parameters:
    ///   - maxAlpha: Maximum value of alpha channel
    ///   - alphaBand: Unpremultiply with this alpha
    public func unpremultiply(maxAlpha: Double? = nil, alphaBand: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let maxAlpha = maxAlpha {
                opt.set("max_alpha", value: maxAlpha)
            }
            if let alphaBand = alphaBand {
                opt.set("alpha_band", value: alphaBand)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("unpremultiply", options: &opt)
        }
    }

    /// Test for equality
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func equal(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .equal)
    }

    /// Test for equality
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func equal(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .equal, c: [value])
    }

    /// Test for inequality
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func notequal(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .noteq)
    }

    /// Test for inequality
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func notequal(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .noteq, c: [value])
    }

    /// Test for less than
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func less(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .less)
    }

    /// Test for less than
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func less(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .less, c: [value])
    }

    /// Test for less than or equal
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func lesseq(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .lesseq)
    }

    /// Test for less than or equal
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func lesseq(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .lesseq, c: [value])
    }

    /// Test for greater than
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func more(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .more)
    }

    /// Test for greater than
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func more(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .more, c: [value])
    }

    /// Test for greater than or equal
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func moreeq(_ rhs: VIPSImage) throws -> VIPSImage {
        return try relational(rhs, relational: .moreeq)
    }

    /// Test for greater than or equal
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func moreeq(_ value: Double) throws -> VIPSImage {
        return try relationalConst(relational: .moreeq, c: [value])
    }

    /// Bitwise AND of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func andimage(_ rhs: VIPSImage) throws -> VIPSImage {
        return try boolean(rhs, boolean: .and)
    }

    /// Bitwise OR of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func orimage(_ rhs: VIPSImage) throws -> VIPSImage {
        return try boolean(rhs, boolean: .or)
    }

    /// Bitwise XOR of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func eorimage(_ rhs: VIPSImage) throws -> VIPSImage {
        return try boolean(rhs, boolean: .eor)
    }

    /// Left shift
    ///
    /// - Parameters:
    ///   - amount: Number of bits to shift
    public func lshift(_ amount: Int) throws -> VIPSImage {
        return try booleanConst(boolean: .lshift, c: [Double(amount)])
    }

    /// Right shift
    ///
    /// - Parameters:
    ///   - amount: Number of bits to shift
    public func rshift(_ amount: Int) throws -> VIPSImage {
        return try booleanConst(boolean: .rshift, c: [Double(amount)])
    }


}

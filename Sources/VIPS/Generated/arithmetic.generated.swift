//
//  arithmetic.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Transform float Lab to signed short
    public func Lab2LabS() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Lab2LabS", options: &opt)
        }
    }

    /// Unpack a LabQ image to short Lab
    public func LabQ2LabS() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabQ2LabS", options: &opt)
        }
    }

    /// Transform signed short Lab to float
    public func LabS2Lab() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabS2Lab", options: &opt)
        }
    }

    /// Transform short Lab to LabQ coding
    public func LabS2LabQ() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabS2LabQ", options: &opt)
        }
    }

    /// Absolute value of an image
    public func abs() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("abs", options: &opt)
        }
    }

    /// Add two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func add(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("add", options: &opt)
        }
    }

    #if SHIM_VIPS_VERSION_8_16
        /// Append an alpha channel
        public func addalpha() throws -> Self {
            return try Self { out in
                var opt = VIPSOption()

                opt.set("in", value: self)
                opt.set("out", value: &out)

                try Self.call("addalpha", options: &opt)
            }
        }
    #endif

    /// Find image average
    public func avg() throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

        opt.set("in", value: self.image)
        opt.set("out", value: &out)

        try Self.call("avg", options: &opt)

        return out
    }

    /// Boolean operation on two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - boolean: Boolean to perform
    public func boolean(_ rhs: some VIPSImageProtocol, boolean: VipsOperationBoolean) throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("boolean", value: boolean)
            opt.set("out", value: &out)

            try Self.call("boolean", options: &opt)
        }
    }

    /// Boolean operations against a constant
    ///
    /// - Parameters:
    ///   - boolean: Boolean to perform
    ///   - c: Array of constants
    public func booleanConst(boolean: VipsOperationBoolean, c: [Double]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("boolean", value: boolean)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try Self.call("boolean_const", options: &opt)
        }
    }

    /// Perform a complex operation on an image
    ///
    /// - Parameters:
    ///   - cmplx: Complex to perform
    public func complex(cmplx: VipsOperationComplex) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("cmplx", value: cmplx)
            opt.set("out", value: &out)

            try Self.call("complex", options: &opt)
        }
    }

    /// Complex binary operations on two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - cmplx: Binary complex operation to perform
    public func complex2(_ rhs: some VIPSImageProtocol, cmplx: VipsOperationComplex2) throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("cmplx", value: cmplx)
            opt.set("out", value: &out)

            try Self.call("complex2", options: &opt)
        }
    }

    /// Form a complex image from two real images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func complexform(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("complexform", options: &opt)
        }
    }

    /// Get a component from a complex image
    ///
    /// - Parameters:
    ///   - `get`: Complex to perform
    public func complexget(`get`: VipsOperationComplexget) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("get", value: `get`)
            opt.set("out", value: &out)

            try Self.call("complexget", options: &opt)
        }
    }

    /// Find image standard deviation
    public func deviate() throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

        opt.set("in", value: self.image)
        opt.set("out", value: &out)

        try Self.call("deviate", options: &opt)

        return out
    }

    /// Divide two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func divide(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("divide", options: &opt)
        }
    }

    /// Invert an image
    public func invert() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("invert", options: &opt)
        }
    }

    /// Build an inverted look-up table
    ///
    /// - Parameters:
    ///   - size: LUT size to generate
    public func invertlut(size: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let size = size {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try Self.call("invertlut", options: &opt)
        }
    }

    /// Apply a math operation to an image
    ///
    /// - Parameters:
    ///   - math: Math to perform
    public func math(_ math: VipsOperationMath) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("math", value: math)
            opt.set("out", value: &out)

            try Self.call("math", options: &opt)
        }
    }

    /// Binary math operations
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - math2: Math to perform
    public func math2(_ rhs: some VIPSImageProtocol, math2: VipsOperationMath2) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("math2", value: math2)
            opt.set("out", value: &out)

            try Self.call("math2", options: &opt)
        }
    }

    /// Binary math operations with a constant
    ///
    /// - Parameters:
    ///   - math2: Math to perform
    ///   - c: Array of constants
    public func math2Const(math2: VipsOperationMath2, c: [Double]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("math2", value: math2)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try Self.call("math2_const", options: &opt)
        }
    }

    /// Invert a matrix
    public func matrixinvert() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("matrixinvert", options: &opt)
        }
    }

    /// Multiply two matrices
    ///
    /// - Parameters:
    ///   - `right`: Second matrix to multiply
    public func matrixmultiply(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("matrixmultiply", options: &opt)
        }
    }

    /// Find image maximum
    ///
    /// - Parameters:
    ///   - size: Number of maximum values to find
    public func max(size: Int? = nil) throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

        opt.set("in", value: self.image)
        if let size = size {
            opt.set("size", value: size)
        }
        opt.set("out", value: &out)

        try Self.call("max", options: &opt)

        return out
    }

    /// Maximum of a pair of images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func maxpair(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("maxpair", options: &opt)
        }
    }

    /// Find image minimum
    ///
    /// - Parameters:
    ///   - size: Number of minimum values to find
    public func min(size: Int? = nil) throws -> Double {
        var opt = VIPSOption()

        var out: Double = 0.0

        opt.set("in", value: self.image)
        if let size = size {
            opt.set("size", value: size)
        }
        opt.set("out", value: &out)

        try Self.call("min", options: &opt)

        return out
    }

    /// Minimum of a pair of images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func minpair(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("minpair", options: &opt)
        }
    }

    /// Multiply two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func multiply(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("multiply", options: &opt)
        }
    }

    #if SHIM_VIPS_VERSION_8_13
        /// Premultiply image alpha
        ///
        /// - Parameters:
        ///   - maxAlpha: Maximum value of alpha channel
        public func premultiply(maxAlpha: Double? = nil) throws -> Self {
            return try Self { out in
                var opt = VIPSOption()

                opt.set("in", value: self)
                if let maxAlpha = maxAlpha {
                    opt.set("max_alpha", value: maxAlpha)
                }
                opt.set("out", value: &out)

                try Self.call("premultiply", options: &opt)
            }
        }
    #endif

    /// Relational operation on two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    ///   - relational: Relational to perform
    public func relational(_ rhs: some VIPSImageProtocol, relational: VipsOperationRelational)
        throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("relational", value: relational)
            opt.set("out", value: &out)

            try Self.call("relational", options: &opt)
        }
    }

    /// Relational operations against a constant
    ///
    /// - Parameters:
    ///   - relational: Relational to perform
    ///   - c: Array of constants
    public func relationalConst(relational: VipsOperationRelational, c: [Double]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("relational", value: relational)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try Self.call("relational_const", options: &opt)
        }
    }

    /// Remainder after integer division of two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func remainder(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("remainder", options: &opt)
        }
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func remainder(_ value: Double) throws -> Self {
        return try remainderConst(c: [value])
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func remainder(_ value: Int) throws -> Self {
        return try remainderConst(c: [Double(value)])
    }

    /// Remainder after integer division of an image and a constant
    ///
    /// - Parameters:
    ///   - c: Array of constants
    public func remainderConst(c: [Double]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try Self.call("remainder_const", options: &opt)
        }
    }

    /// Perform a round function on an image
    ///
    /// - Parameters:
    ///   - round: Rounding operation to perform
    public func round(_ round: VipsOperationRound) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("round", value: round)
            opt.set("out", value: &out)

            try Self.call("round", options: &opt)
        }
    }

    /// Unit vector of pixel
    public func sign() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sign", options: &opt)
        }
    }

    /// Find many image stats
    public func stats() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("stats", options: &opt)
        }
    }

    /// Subtract two images
    ///
    /// - Parameters:
    ///   - `right`: Right-hand image argument
    public func subtract(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("subtract", options: &opt)
        }
    }

    #if SHIM_VIPS_VERSION_8_13
        /// Unpremultiply image alpha
        ///
        /// - Parameters:
        ///   - maxAlpha: Maximum value of alpha channel
        ///   - alphaBand: Unpremultiply with this alpha
        public func unpremultiply(maxAlpha: Double? = nil, alphaBand: Int? = nil) throws -> Self {
            return try Self { out in
                var opt = VIPSOption()

                opt.set("in", value: self)
                if let maxAlpha = maxAlpha {
                    opt.set("max_alpha", value: maxAlpha)
                }
                if let alphaBand = alphaBand {
                    opt.set("alpha_band", value: alphaBand)
                }
                opt.set("out", value: &out)

                try Self.call("unpremultiply", options: &opt)
            }
        }
    #endif

    /// Test for equality
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func equal(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .equal)
    }

    /// Test for equality
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func equal(_ value: Double) throws -> Self {
        return try relationalConst(relational: .equal, c: [value])
    }

    /// Test for inequality
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func notequal(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .noteq)
    }

    /// Test for inequality
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func notequal(_ value: Double) throws -> Self {
        return try relationalConst(relational: .noteq, c: [value])
    }

    /// Test for less than
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func less(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .less)
    }

    /// Test for less than
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func less(_ value: Double) throws -> Self {
        return try relationalConst(relational: .less, c: [value])
    }

    /// Test for less than or equal
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func lesseq(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .lesseq)
    }

    /// Test for less than or equal
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func lesseq(_ value: Double) throws -> Self {
        return try relationalConst(relational: .lesseq, c: [value])
    }

    /// Test for greater than
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func more(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .more)
    }

    /// Test for greater than
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func more(_ value: Double) throws -> Self {
        return try relationalConst(relational: .more, c: [value])
    }

    /// Test for greater than or equal
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func moreeq(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try relational(rhs, relational: .moreeq)
    }

    /// Test for greater than or equal
    ///
    /// - Parameters:
    ///   - value: Constant value
    public func moreeq(_ value: Double) throws -> Self {
        return try relationalConst(relational: .moreeq, c: [value])
    }

    /// Bitwise AND of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func andimage(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try boolean(rhs, boolean: .and)
    }

    /// Bitwise OR of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func orimage(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try boolean(rhs, boolean: .or)
    }

    /// Bitwise XOR of two images
    ///
    /// - Parameters:
    ///   - rhs: Right-hand input image
    public func eorimage(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try boolean(rhs, boolean: .eor)
    }

    /// Left shift
    ///
    /// - Parameters:
    ///   - amount: Number of bits to shift
    public func lshift(_ amount: Int) throws -> Self {
        return try booleanConst(boolean: .lshift, c: [Double(amount)])
    }

    /// Right shift
    ///
    /// - Parameters:
    ///   - amount: Number of bits to shift
    public func rshift(_ amount: Int) throws -> Self {
        return try booleanConst(boolean: .rshift, c: [Double(amount)])
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Sum an array of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    public static func sum(_ `in`: [VIPSImage]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("out", value: &out)

            try Self.call("sum", options: &opt)
        }
    }

}

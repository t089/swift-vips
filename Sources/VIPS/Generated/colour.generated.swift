//
//  colour.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Transform LCh to CMC
    public func CMC2LCh() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("CMC2LCh", options: &opt)
        }
    }

    /// Transform CMYK to XYZ
    public func CMYK2XYZ() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("CMYK2XYZ", options: &opt)
        }
    }

    /// Transform HSV to sRGB
    public func HSV2sRGB() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("HSV2sRGB", options: &opt)
        }
    }

    /// Transform LCh to CMC
    public func LCh2CMC() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LCh2CMC", options: &opt)
        }
    }

    /// Transform LCh to Lab
    public func LCh2Lab() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LCh2Lab", options: &opt)
        }
    }

    /// Transform Lab to LCh
    public func Lab2LCh() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Lab2LCh", options: &opt)
        }
    }

    /// Transform float Lab to LabQ coding
    public func Lab2LabQ() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Lab2LabQ", options: &opt)
        }
    }

    /// Transform CIELAB to XYZ
    ///
    /// - Parameters:
    ///   - temp: Color temperature
    public func Lab2XYZ(temp: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let temp = temp {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try Self.call("Lab2XYZ", options: &opt)
        }
    }

    /// Unpack a LabQ image to float Lab
    public func LabQ2Lab() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabQ2Lab", options: &opt)
        }
    }

    /// Convert a LabQ image to sRGB
    public func LabQ2sRGB() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabQ2sRGB", options: &opt)
        }
    }

    /// Transform XYZ to CMYK
    public func XYZ2CMYK() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2CMYK", options: &opt)
        }
    }

    /// Transform XYZ to Lab
    ///
    /// - Parameters:
    ///   - temp: Colour temperature
    public func XYZ2Lab(temp: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let temp = temp {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try Self.call("XYZ2Lab", options: &opt)
        }
    }

    /// Transform XYZ to Yxy
    public func XYZ2Yxy() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2Yxy", options: &opt)
        }
    }

    /// Transform XYZ to scRGB
    public func XYZ2scRGB() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2scRGB", options: &opt)
        }
    }

    /// Transform Yxy to XYZ
    public func Yxy2XYZ() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Yxy2XYZ", options: &opt)
        }
    }

    /// Convert to a new colorspace
    ///
    /// - Parameters:
    ///   - space: Destination color space
    ///   - sourceSpace: Source color space
    public func colourspace(space: VipsInterpretation, sourceSpace: VipsInterpretation? = nil)
        throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("space", value: space)
            if let sourceSpace = sourceSpace {
                opt.set("source_space", value: sourceSpace)
            }
            opt.set("out", value: &out)

            try Self.call("colourspace", options: &opt)
        }
    }

    /// False-color an image
    public func falsecolour() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("falsecolour", options: &opt)
        }
    }

    /// Output to device with ICC profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - outputProfile: Filename to load output profile from
    ///   - depth: Output device space depth in bits
    public func iccExport(
        pcs: VipsPCS? = nil,
        intent: VipsIntent? = nil,
        blackPointCompensation: Bool? = nil,
        outputProfile: String? = nil,
        depth: Int? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if let outputProfile = outputProfile {
                opt.set("output_profile", value: outputProfile)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("icc_export", options: &opt)
        }
    }

    /// Import from device with ICC profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    public func iccImport(
        pcs: VipsPCS? = nil,
        intent: VipsIntent? = nil,
        blackPointCompensation: Bool? = nil,
        embedded: Bool? = nil,
        inputProfile: String? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if let embedded = embedded {
                opt.set("embedded", value: embedded)
            }
            if let inputProfile = inputProfile {
                opt.set("input_profile", value: inputProfile)
            }
            opt.set("out", value: &out)

            try Self.call("icc_import", options: &opt)
        }
    }

    /// Transform between devices with ICC profiles
    ///
    /// - Parameters:
    ///   - outputProfile: Filename to load output profile from
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    ///   - depth: Output device space depth in bits
    public func iccTransform(
        outputProfile: String,
        pcs: VipsPCS? = nil,
        intent: VipsIntent? = nil,
        blackPointCompensation: Bool? = nil,
        embedded: Bool? = nil,
        inputProfile: String? = nil,
        depth: Int? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("output_profile", value: outputProfile)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if let embedded = embedded {
                opt.set("embedded", value: embedded)
            }
            if let inputProfile = inputProfile {
                opt.set("input_profile", value: inputProfile)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("icc_transform", options: &opt)
        }
    }

    /// Label regions in an image
    public func labelregions() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("labelregions", options: &opt)
        }
    }

    /// Transform sRGB to HSV
    public func sRGB2HSV() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sRGB2HSV", options: &opt)
        }
    }

    /// Convert an sRGB image to scRGB
    public func sRGB2scRGB() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sRGB2scRGB", options: &opt)
        }
    }

    /// Convert scRGB to BW
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scRGB2BW(depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("scRGB2BW", options: &opt)
        }
    }

    /// Transform scRGB to XYZ
    public func scRGB2XYZ() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("scRGB2XYZ", options: &opt)
        }
    }

    /// Convert scRGB to sRGB
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scRGB2sRGB(depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("scRGB2sRGB", options: &opt)
        }
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Make an image where pixel values are coordinates
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - csize: Size of third dimension
    ///   - dsize: Size of fourth dimension
    ///   - esize: Size of fifth dimension
    public static func xyz(
        width: Int,
        height: Int,
        csize: Int? = nil,
        dsize: Int? = nil,
        esize: Int? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let csize = csize {
                opt.set("csize", value: csize)
            }
            if let dsize = dsize {
                opt.set("dsize", value: dsize)
            }
            if let esize = esize {
                opt.set("esize", value: esize)
            }
            opt.set("out", value: &out)

            try Self.call("xyz", options: &opt)
        }
    }

}

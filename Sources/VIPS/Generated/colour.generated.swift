//
//  colour.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Transform LCh to CMC
    public func cmc2lch() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("CMC2LCh", options: &opt)
        }
    }

    /// Transform CMYK to XYZ
    public func cmyk2xyz() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("CMYK2XYZ", options: &opt)
        }
    }

    /// Transform HSV to sRGB
    public func hsv2srgb() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("HSV2sRGB", options: &opt)
        }
    }

    /// Transform LCh to CMC
    public func lch2cmc() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LCh2CMC", options: &opt)
        }
    }

    /// Transform LCh to Lab
    public func lch2lab() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LCh2Lab", options: &opt)
        }
    }

    /// Transform Lab to LCh
    public func lab2lch() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Lab2LCh", options: &opt)
        }
    }

    /// Transform float Lab to LabQ coding
    public func lab2labq() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Lab2LabQ", options: &opt)
        }
    }

    /// Transform CIELAB to XYZ
    ///
    /// - Parameters:
    ///   - temp: Color temperature
    public func lab2xyz(temp: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let temp = temp {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try Self.call("Lab2XYZ", options: &opt)
        }
    }

    /// Unpack a LabQ image to float Lab
    public func labq2lab() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabQ2Lab", options: &opt)
        }
    }

    /// Convert a LabQ image to sRGB
    public func labq2srgb() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("LabQ2sRGB", options: &opt)
        }
    }

    /// Transform XYZ to CMYK
    public func xyz2cmyk() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2CMYK", options: &opt)
        }
    }

    /// Transform XYZ to Lab
    ///
    /// - Parameters:
    ///   - temp: Colour temperature
    public func xyz2lab(temp: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let temp = temp {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try Self.call("XYZ2Lab", options: &opt)
        }
    }

    /// Transform XYZ to Yxy
    public func xyz2yxy() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2Yxy", options: &opt)
        }
    }

    /// Transform XYZ to scRGB
    public func xyz2scrgb() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("XYZ2scRGB", options: &opt)
        }
    }

    /// Transform Yxy to XYZ
    public func yxy2xyz() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("Yxy2XYZ", options: &opt)
        }
    }

    /// Convert to a new colorspace
    ///
    /// - Parameters:
    ///   - space: Destination color space
    ///   - sourceSpace: Source color space
    public func colourspace(space: VipsInterpretation, sourceSpace: VipsInterpretation? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("space", value: space)
            if let sourceSpace = sourceSpace {
                opt.set("source-space", value: sourceSpace)
            }
            opt.set("out", value: &out)

            try Self.call("colourspace", options: &opt)
        }
    }

    /// False-color an image
    public func falsecolour() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("falsecolour", options: &opt)
        }
    }

    /// Output to device with ICC profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - outputProfile: Filename to load output profile from
    ///   - depth: Output device space depth in bits
    public func iccExport(pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool? = nil, outputProfile: String? = nil, depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black-point-compensation", value: blackPointCompensation)
            }
            if let outputProfile = outputProfile {
                opt.set("output-profile", value: outputProfile)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("icc_export", options: &opt)
        }
    }

    /// Import from device with ICC profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    public func iccImport(pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool? = nil, embedded: Bool? = nil, inputProfile: String? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black-point-compensation", value: blackPointCompensation)
            }
            if let embedded = embedded {
                opt.set("embedded", value: embedded)
            }
            if let inputProfile = inputProfile {
                opt.set("input-profile", value: inputProfile)
            }
            opt.set("out", value: &out)

            try Self.call("icc_import", options: &opt)
        }
    }

    /// Transform between devices with ICC profiles
    ///
    /// - Parameters:
    ///   - outputProfile: Filename to load output profile from
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    ///   - depth: Output device space depth in bits
    public func iccTransform(outputProfile: String, pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool? = nil, embedded: Bool? = nil, inputProfile: String? = nil, depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("output-profile", value: outputProfile)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if let blackPointCompensation = blackPointCompensation {
                opt.set("black-point-compensation", value: blackPointCompensation)
            }
            if let embedded = embedded {
                opt.set("embedded", value: embedded)
            }
            if let inputProfile = inputProfile {
                opt.set("input-profile", value: inputProfile)
            }
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("icc_transform", options: &opt)
        }
    }

    /// Label regions in an image
    public func labelregions() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("labelregions", options: &opt)
        }
    }

    /// Transform sRGB to HSV
    public func srgb2hsv() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sRGB2HSV", options: &opt)
        }
    }

    /// Convert an sRGB image to scRGB
    public func srgb2scrgb() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sRGB2scRGB", options: &opt)
        }
    }

    /// Convert scRGB to BW
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scrgb2bw(depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("scRGB2BW", options: &opt)
        }
    }

    /// Transform scRGB to XYZ
    public func scrgb2xyz() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("scRGB2XYZ", options: &opt)
        }
    }

    /// Convert scRGB to sRGB
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scrgb2srgb(depth: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let depth = depth {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try Self.call("scRGB2sRGB", options: &opt)
        }
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Make an image where pixel values are coordinates
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - csize: Size of third dimension
    ///   - dsize: Size of fourth dimension
    ///   - esize: Size of fifth dimension
    public static func xyz(width: Int, height: Int, csize: Int? = nil, dsize: Int? = nil, esize: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let csize = csize {
                opt.set("csize", value: csize)
            }
            if let dsize = dsize {
                opt.set("dsize", value: dsize)
            }
            if let esize = esize {
                opt.set("esize", value: esize)
            }
            opt.set("out", value: &out)

            try Self.call("xyz", options: &opt)
        }
    }

}

//
//  colour.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Transform lch to cmc
    public func CMC2LCh() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("CMC2LCh", options: &opt)
        }
    }

    /// Transform cmyk to xyz
    public func CMYK2XYZ() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("CMYK2XYZ", options: &opt)
        }
    }

    /// Transform hsv to srgb
    public func HSV2sRGB() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("HSV2sRGB", options: &opt)
        }
    }

    /// Transform lch to cmc
    public func LCh2CMC() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("LCh2CMC", options: &opt)
        }
    }

    /// Transform lch to lab
    public func LCh2Lab() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("LCh2Lab", options: &opt)
        }
    }

    /// Transform lab to lch
    public func Lab2LCh() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("Lab2LCh", options: &opt)
        }
    }

    /// Transform float lab to labq coding
    public func Lab2LabQ() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("Lab2LabQ", options: &opt)
        }
    }

    /// Transform cielab to xyz
    ///
    /// - Parameters:
    ///   - temp: Color temperature
    public func Lab2XYZ(temp: [Double] = []) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if temp != [] {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("Lab2XYZ", options: &opt)
        }
    }

    /// Unpack a labq image to float lab
    public func LabQ2Lab() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("LabQ2Lab", options: &opt)
        }
    }

    /// Convert a labq image to srgb
    public func LabQ2sRGB() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("LabQ2sRGB", options: &opt)
        }
    }

    /// Transform xyz to cmyk
    public func XYZ2CMYK() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("XYZ2CMYK", options: &opt)
        }
    }

    /// Transform xyz to lab
    ///
    /// - Parameters:
    ///   - temp: Colour temperature
    public func XYZ2Lab(temp: [Double] = []) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if temp != [] {
                opt.set("temp", value: temp)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("XYZ2Lab", options: &opt)
        }
    }

    /// Transform xyz to yxy
    public func XYZ2Yxy() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("XYZ2Yxy", options: &opt)
        }
    }

    /// Transform xyz to scrgb
    public func XYZ2scRGB() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("XYZ2scRGB", options: &opt)
        }
    }

    /// Transform yxy to xyz
    public func Yxy2XYZ() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("Yxy2XYZ", options: &opt)
        }
    }

    /// Convert to a new colorspace
    ///
    /// - Parameters:
    ///   - space: Destination color space
    ///   - sourceSpace: Source color space
    public func colourspace(space: VipsInterpretation, sourceSpace: VipsInterpretation? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("space", value: space)
            if let sourceSpace = sourceSpace {
                opt.set("source_space", value: sourceSpace)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("colourspace", options: &opt)
        }
    }

    /// False-color an image
    public func falsecolour() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("falsecolour", options: &opt)
        }
    }

    /// Output to device with icc profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - outputProfile: Filename to load output profile from
    ///   - depth: Output device space depth in bits
    public func iccExport(pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool = false, outputProfile: String = "", depth: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if blackPointCompensation != false {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if outputProfile != "" {
                opt.set("output_profile", value: outputProfile)
            }
            if depth != 0 {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("icc_export", options: &opt)
        }
    }

    /// Import from device with icc profile
    ///
    /// - Parameters:
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    public func iccImport(pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool = false, embedded: Bool = false, inputProfile: String = "") throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if blackPointCompensation != false {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if embedded != false {
                opt.set("embedded", value: embedded)
            }
            if inputProfile != "" {
                opt.set("input_profile", value: inputProfile)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("icc_import", options: &opt)
        }
    }

    /// Transform between devices with icc profiles
    ///
    /// - Parameters:
    ///   - outputProfile: Filename to load output profile from
    ///   - pcs: Set Profile Connection Space
    ///   - intent: Rendering intent
    ///   - blackPointCompensation: Enable black point compensation
    ///   - embedded: Use embedded input profile, if available
    ///   - inputProfile: Filename to load input profile from
    ///   - depth: Output device space depth in bits
    public func iccTransform(outputProfile: String, pcs: VipsPCS? = nil, intent: VipsIntent? = nil, blackPointCompensation: Bool = false, embedded: Bool = false, inputProfile: String = "", depth: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("output_profile", value: outputProfile)
            if let pcs = pcs {
                opt.set("pcs", value: pcs)
            }
            if let intent = intent {
                opt.set("intent", value: intent)
            }
            if blackPointCompensation != false {
                opt.set("black_point_compensation", value: blackPointCompensation)
            }
            if embedded != false {
                opt.set("embedded", value: embedded)
            }
            if inputProfile != "" {
                opt.set("input_profile", value: inputProfile)
            }
            if depth != 0 {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("icc_transform", options: &opt)
        }
    }

    /// Label regions in an image
    public func labelregions() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: &out)

            try VIPSImage.call("labelregions", options: &opt)
        }
    }

    /// Transform srgb to hsv
    public func sRGB2HSV() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("sRGB2HSV", options: &opt)
        }
    }

    /// Convert an srgb image to scrgb
    public func sRGB2scRGB() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("sRGB2scRGB", options: &opt)
        }
    }

    /// Convert scrgb to bw
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scRGB2BW(depth: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if depth != 0 {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("scRGB2BW", options: &opt)
        }
    }

    /// Transform scrgb to xyz
    public func scRGB2XYZ() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("scRGB2XYZ", options: &opt)
        }
    }

    /// Convert an scrgb image to srgb
    ///
    /// - Parameters:
    ///   - depth: Output device space depth in bits
    public func scRGB2sRGB(depth: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if depth != 0 {
                opt.set("depth", value: depth)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("scRGB2sRGB", options: &opt)
        }
    }

    /// Make an image where pixel values are coordinates
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - csize: Size of third dimension
    ///   - dsize: Size of fourth dimension
    ///   - esize: Size of fifth dimension
    public static func xyz(width: Int, height: Int, csize: Int = 0, dsize: Int = 0, esize: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if csize != 0 {
                opt.set("csize", value: csize)
            }
            if dsize != 0 {
                opt.set("dsize", value: dsize)
            }
            if esize != 0 {
                opt.set("esize", value: esize)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("xyz", options: &opt)
        }
    }

}

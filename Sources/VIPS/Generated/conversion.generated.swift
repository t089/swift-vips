//
//  conversion.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Affine transform of an image
    ///
    /// - Parameters:
    ///   - matrix: Transformation matrix
    ///   - interpolate: Interpolate pixels with this
    ///   - oarea: Area of output to generate
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    ///   - background: Background value
    ///   - premultiplied: Images have premultiplied alpha
    ///   - extend: How to generate the extra pixels
    public func affine(matrix: [Double], interpolate: VIPSInterpolate? = nil, oarea: [Int] = [], odx: Double = 0.0, ody: Double = 0.0, idx: Double = 0.0, idy: Double = 0.0, background: [Double] = [], premultiplied: Bool = false, extend: VipsExtend? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("matrix", value: matrix)
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if oarea != [] {
                opt.set("oarea", value: oarea)
            }
            if odx != 0.0 {
                opt.set("odx", value: odx)
            }
            if ody != 0.0 {
                opt.set("ody", value: ody)
            }
            if idx != 0.0 {
                opt.set("idx", value: idx)
            }
            if idy != 0.0 {
                opt.set("idy", value: idy)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if premultiplied != false {
                opt.set("premultiplied", value: premultiplied)
            }
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("affine", options: &opt)
        }
    }

    /// Join an array of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - across: Number of images across grid
    ///   - shim: Pixels between images
    ///   - background: Colour for new pixels
    ///   - halign: Align on the left, centre or right
    ///   - valign: Align on the top, centre or bottom
    ///   - hspacing: Horizontal spacing between images
    ///   - vspacing: Vertical spacing between images
    public static func arrayjoin(`in`: [VIPSImage], across: Int = 0, shim: Int = 0, background: [Double] = [], halign: VipsAlign? = nil, valign: VipsAlign? = nil, hspacing: Int = 0, vspacing: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            if across != 0 {
                opt.set("across", value: across)
            }
            if shim != 0 {
                opt.set("shim", value: shim)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if let halign = halign {
                opt.set("halign", value: halign)
            }
            if let valign = valign {
                opt.set("valign", value: valign)
            }
            if hspacing != 0 {
                opt.set("hspacing", value: hspacing)
            }
            if vspacing != 0 {
                opt.set("vspacing", value: vspacing)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("arrayjoin", options: &opt)
        }
    }

    /// Autorotate image by exif tag
    public func autorot() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("autorot", options: &opt)
        }
    }

    /// Bandwise join a set of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    public static func bandjoin(`in`: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("out", value: &out)

            try VIPSImage.call("bandjoin", options: &opt)
        }
    }

    /// Append a constant band to an image
    ///
    /// - Parameters:
    ///   - c: Array of constants to add
    public func bandjoinConst(c: [Double]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try VIPSImage.call("bandjoin_const", options: &opt)
        }
    }

    /// Band-wise rank of a set of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - index: Select this band element from sorted list
    public static func bandrank(`in`: [VIPSImage], index: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            if index != 0 {
                opt.set("index", value: index)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("bandrank", options: &opt)
        }
    }

    /// Cast an image
    ///
    /// - Parameters:
    ///   - format: Format to cast to
    ///   - shift: Shift integer values up and down
    public func cast(format: VipsBandFormat, shift: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("format", value: format)
            if shift != false {
                opt.set("shift", value: shift)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("cast", options: &opt)
        }
    }

    /// Blend an array of images with an array of blend modes
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - mode: Array of VipsBlendMode to join with
    ///   - x: Array of x coordinates to join at
    ///   - y: Array of y coordinates to join at
    ///   - compositingSpace: Composite images in this colour space
    ///   - premultiplied: Images have premultiplied alpha
    public static func composite(`in`: [VIPSImage], mode: [Int], x: [Int] = [], y: [Int] = [], compositingSpace: VipsInterpretation? = nil, premultiplied: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("mode", value: mode)
            if x != [] {
                opt.set("x", value: x)
            }
            if y != [] {
                opt.set("y", value: y)
            }
            if let compositingSpace = compositingSpace {
                opt.set("compositing_space", value: compositingSpace)
            }
            if premultiplied != false {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("composite", options: &opt)
        }
    }

    /// Blend a pair of images with a blend mode
    ///
    /// - Parameters:
    ///   - overlay: Overlay image
    ///   - mode: VipsBlendMode to join with
    ///   - x: x position of overlay
    ///   - y: y position of overlay
    ///   - compositingSpace: Composite images in this colour space
    ///   - premultiplied: Images have premultiplied alpha
    public func composite2(overlay: VIPSImage, mode: VipsBlendMode, x: Int = 0, y: Int = 0, compositingSpace: VipsInterpretation? = nil, premultiplied: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("base", value: self.image)
            opt.set("overlay", value: overlay)
            opt.set("mode", value: mode)
            if x != 0 {
                opt.set("x", value: x)
            }
            if y != 0 {
                opt.set("y", value: y)
            }
            if let compositingSpace = compositingSpace {
                opt.set("compositing_space", value: compositingSpace)
            }
            if premultiplied != false {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("composite2", options: &opt)
        }
    }

    /// Copy an image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - format: Pixel format in image
    ///   - coding: Pixel coding
    ///   - interpretation: Pixel interpretation
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - xoffset: Horizontal offset of origin
    ///   - yoffset: Vertical offset of origin
    public func copy(width: Int = 0, height: Int = 0, bands: Int = 0, format: VipsBandFormat? = nil, coding: VipsCoding? = nil, interpretation: VipsInterpretation? = nil, xres: Double = 0.0, yres: Double = 0.0, xoffset: Int = 0, yoffset: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if width != 0 {
                opt.set("width", value: width)
            }
            if height != 0 {
                opt.set("height", value: height)
            }
            if bands != 0 {
                opt.set("bands", value: bands)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let coding = coding {
                opt.set("coding", value: coding)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if xres != 0.0 {
                opt.set("xres", value: xres)
            }
            if yres != 0.0 {
                opt.set("yres", value: yres)
            }
            if xoffset != 0 {
                opt.set("xoffset", value: xoffset)
            }
            if yoffset != 0 {
                opt.set("yoffset", value: yoffset)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("copy", options: &opt)
        }
    }

    /// Extract an area from an image
    ///
    /// - Parameters:
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func crop(`left`: Int, top: Int, width: Int, height: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self.image)
            opt.set("left", value: `left`)
            opt.set("top", value: top)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("out", value: &out)

            try VIPSImage.call("crop", options: &opt)
        }
    }

    /// Embed an image in a larger image
    ///
    /// - Parameters:
    ///   - x: Left edge of input in output
    ///   - y: Top edge of input in output
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - extend: How to generate the extra pixels
    ///   - background: Color for background pixels
    public func embed(x: Int, y: Int, width: Int, height: Int, extend: VipsExtend? = nil, background: [Double] = []) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("x", value: x)
            opt.set("y", value: y)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("embed", options: &opt)
        }
    }

    /// Extract an area from an image
    ///
    /// - Parameters:
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func extractArea(`left`: Int, top: Int, width: Int, height: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self.image)
            opt.set("left", value: `left`)
            opt.set("top", value: top)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("out", value: &out)

            try VIPSImage.call("extract_area", options: &opt)
        }
    }

    /// Extract band from an image
    ///
    /// - Parameters:
    ///   - band: Band to extract
    ///   - n: Number of bands to extract
    public func extractBand(band: Int, n: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("band", value: band)
            if n != 0 {
                opt.set("n", value: n)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("extract_band", options: &opt)
        }
    }

    /// Flip an image
    ///
    /// - Parameters:
    ///   - direction: Direction to flip image
    public func flip(direction: VipsDirection) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("direction", value: direction)
            opt.set("out", value: &out)

            try VIPSImage.call("flip", options: &opt)
        }
    }

    /// Grid an image
    ///
    /// - Parameters:
    ///   - tileHeight: Chop into tiles this high
    ///   - across: Number of tiles across
    ///   - down: Number of tiles down
    public func grid(tileHeight: Int, across: Int, down: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("tile_height", value: tileHeight)
            opt.set("across", value: across)
            opt.set("down", value: down)
            opt.set("out", value: &out)

            try VIPSImage.call("grid", options: &opt)
        }
    }

    /// Insert image @sub into @main at @x, @y
    ///
    /// - Parameters:
    ///   - sub: Sub-image to insert into main image
    ///   - x: Left edge of sub in main
    ///   - y: Top edge of sub in main
    ///   - expand: Expand output to hold all of both inputs
    ///   - background: Color for new pixels
    public func insert(sub: VIPSImage, x: Int, y: Int, expand: Bool = false, background: [Double] = []) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("main", value: self.image)
            opt.set("sub", value: sub)
            opt.set("x", value: x)
            opt.set("y", value: y)
            if expand != false {
                opt.set("expand", value: expand)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("insert", options: &opt)
        }
    }

    /// Join a pair of images
    ///
    /// - Parameters:
    ///   - in2: Second input image
    ///   - direction: Join left-right or up-down
    ///   - expand: Expand output to hold all of both inputs
    ///   - shim: Pixels between images
    ///   - background: Colour for new pixels
    ///   - align: Align on the low, centre or high coordinate edge
    public func join(in2: VIPSImage, direction: VipsDirection, expand: Bool = false, shim: Int = 0, background: [Double] = [], align: VipsAlign? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in1", value: self.image)
            opt.set("in2", value: in2)
            opt.set("direction", value: direction)
            if expand != false {
                opt.set("expand", value: expand)
            }
            if shim != 0 {
                opt.set("shim", value: shim)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if let align = align {
                opt.set("align", value: align)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("join", options: &opt)
        }
    }

    /// Linear recombination with matrix
    ///
    /// - Parameters:
    ///   - m: Matrix of coefficients
    public func recomb(m: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("m", value: m)
            opt.set("out", value: &out)

            try VIPSImage.call("recomb", options: &opt)
        }
    }

    /// Reduce an image
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - vshrink: Vertical shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reduce(hshrink: Double, vshrink: Double, kernel: VipsKernel? = nil, gap: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("hshrink", value: hshrink)
            opt.set("vshrink", value: vshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if gap != 0.0 {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("reduce", options: &opt)
        }
    }

    /// Shrink an image horizontally
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reduceh(hshrink: Double, kernel: VipsKernel? = nil, gap: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("hshrink", value: hshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if gap != 0.0 {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("reduceh", options: &opt)
        }
    }

    /// Shrink an image vertically
    ///
    /// - Parameters:
    ///   - vshrink: Vertical shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reducev(vshrink: Double, kernel: VipsKernel? = nil, gap: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("vshrink", value: vshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if gap != 0.0 {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("reducev", options: &opt)
        }
    }

    /// Resize an image
    ///
    /// - Parameters:
    ///   - scale: Scale image by this factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    ///   - vscale: Vertical scale image by this factor
    public func resize(scale: Double, kernel: VipsKernel? = nil, gap: Double = 0.0, vscale: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("scale", value: scale)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if gap != 0.0 {
                opt.set("gap", value: gap)
            }
            if vscale != 0.0 {
                opt.set("vscale", value: vscale)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("resize", options: &opt)
        }
    }

    /// Rotate an image
    ///
    /// - Parameters:
    ///   - angle: Angle to rotate image
    public func rot(angle: VipsAngle) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("angle", value: angle)
            opt.set("out", value: &out)

            try VIPSImage.call("rot", options: &opt)
        }
    }

    /// Rotate an image
    ///
    /// - Parameters:
    ///   - angle: Angle to rotate image
    public func rot45(angle: VipsAngle45? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("rot45", options: &opt)
        }
    }

    /// Rotate an image by a number of degrees
    ///
    /// - Parameters:
    ///   - angle: Rotate anticlockwise by this many degrees
    ///   - interpolate: Interpolate pixels with this
    ///   - background: Background value
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    public func rotate(angle: Double, interpolate: VIPSInterpolate? = nil, background: [Double] = [], odx: Double = 0.0, ody: Double = 0.0, idx: Double = 0.0, idy: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("angle", value: angle)
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if odx != 0.0 {
                opt.set("odx", value: odx)
            }
            if ody != 0.0 {
                opt.set("ody", value: ody)
            }
            if idx != 0.0 {
                opt.set("idx", value: idx)
            }
            if idy != 0.0 {
                opt.set("idy", value: idy)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("rotate", options: &opt)
        }
    }

    /// Scale an image to uchar
    ///
    /// - Parameters:
    ///   - exp: Exponent for log scale
    ///   - log: Log scale
    public func scale(exp: Double = 0.0, log: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if exp != 0.0 {
                opt.set("exp", value: exp)
            }
            if log != false {
                opt.set("log", value: log)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("scale", options: &opt)
        }
    }

    /// Shrink an image
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - vshrink: Vertical shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrink(hshrink: Double, vshrink: Double, ceil: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("hshrink", value: hshrink)
            opt.set("vshrink", value: vshrink)
            if ceil != false {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("shrink", options: &opt)
        }
    }

    /// Shrink an image horizontally
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrinkh(hshrink: Int, ceil: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("hshrink", value: hshrink)
            if ceil != false {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("shrinkh", options: &opt)
        }
    }

    /// Shrink an image vertically
    ///
    /// - Parameters:
    ///   - vshrink: Vertical shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrinkv(vshrink: Int, ceil: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("vshrink", value: vshrink)
            if ceil != false {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("shrinkv", options: &opt)
        }
    }

    /// Similarity transform of an image
    ///
    /// - Parameters:
    ///   - scale: Scale by this factor
    ///   - angle: Rotate anticlockwise by this many degrees
    ///   - interpolate: Interpolate pixels with this
    ///   - background: Background value
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    public func similarity(scale: Double = 0.0, angle: Double = 0.0, interpolate: VIPSInterpolate? = nil, background: [Double] = [], odx: Double = 0.0, ody: Double = 0.0, idx: Double = 0.0, idy: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if scale != 0.0 {
                opt.set("scale", value: scale)
            }
            if angle != 0.0 {
                opt.set("angle", value: angle)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if odx != 0.0 {
                opt.set("odx", value: odx)
            }
            if ody != 0.0 {
                opt.set("ody", value: ody)
            }
            if idx != 0.0 {
                opt.set("idx", value: idx)
            }
            if idy != 0.0 {
                opt.set("idy", value: idy)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("similarity", options: &opt)
        }
    }

    /// Extract an area from an image
    ///
    /// - Parameters:
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    ///   - interesting: How to measure interestingness
    ///   - premultiplied: Input image already has premultiplied alpha
    public func smartcrop(width: Int, height: Int, interesting: VipsInteresting? = nil, premultiplied: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self.image)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let interesting = interesting {
                opt.set("interesting", value: interesting)
            }
            if premultiplied != false {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("smartcrop", options: &opt)
        }
    }

    /// Cache an image as a set of tiles
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - maxTiles: Maximum number of tiles to cache
    ///   - access: Expected access pattern
    ///   - threaded: Allow threaded access
    ///   - persistent: Keep cache between evaluations
    public func tilecache(tileWidth: Int = 0, tileHeight: Int = 0, maxTiles: Int = 0, access: VipsAccess? = nil, threaded: Bool = false, persistent: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if maxTiles != 0 {
                opt.set("max_tiles", value: maxTiles)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if threaded != false {
                opt.set("threaded", value: threaded)
            }
            if persistent != false {
                opt.set("persistent", value: persistent)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tilecache", options: &opt)
        }
    }

    /// Transpose3d an image
    ///
    /// - Parameters:
    ///   - pageHeight: Height of each input page
    public func transpose3d(pageHeight: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if pageHeight != 0 {
                opt.set("page_height", value: pageHeight)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("transpose3d", options: &opt)
        }
    }

    /// Wrap image origin
    ///
    /// - Parameters:
    ///   - x: Left edge of input in output
    ///   - y: Top edge of input in output
    public func wrap(x: Int = 0, y: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if x != 0 {
                opt.set("x", value: x)
            }
            if y != 0 {
                opt.set("y", value: y)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("wrap", options: &opt)
        }
    }

    /// Zoom an image
    ///
    /// - Parameters:
    ///   - xfac: Horizontal zoom factor
    ///   - yfac: Vertical zoom factor
    public func zoom(xfac: Int, yfac: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self.image)
            opt.set("xfac", value: xfac)
            opt.set("yfac", value: yfac)
            opt.set("out", value: &out)

            try VIPSImage.call("zoom", options: &opt)
        }
    }

}

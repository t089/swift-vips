//
//  conversion.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Affine transform of an image
    ///
    /// - Parameters:
    ///   - matrix: Transformation matrix
    ///   - interpolate: Interpolate pixels with this
    ///   - oarea: Area of output to generate
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    ///   - background: Background value
    ///   - premultiplied: Images have premultiplied alpha
    ///   - extend: How to generate the extra pixels
    public func affine(matrix: [Double], interpolate: VIPSInterpolate? = nil, oarea: [Int]? = nil, odx: Double? = nil, ody: Double? = nil, idx: Double? = nil, idy: Double? = nil, background: [Double]? = nil, premultiplied: Bool? = nil, extend: VipsExtend? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("matrix", value: matrix)
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if let oarea = oarea {
                opt.set("oarea", value: oarea)
            }
            if let odx = odx {
                opt.set("odx", value: odx)
            }
            if let ody = ody {
                opt.set("ody", value: ody)
            }
            if let idx = idx {
                opt.set("idx", value: idx)
            }
            if let idy = idy {
                opt.set("idy", value: idy)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let premultiplied = premultiplied {
                opt.set("premultiplied", value: premultiplied)
            }
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            opt.set("out", value: &out)

            try Self.call("affine", options: &opt)
        }
    }

    /// Autorotate image by exif tag
    public func autorot() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("autorot", options: &opt)
        }
    }

    /// Append a constant band to an image
    ///
    /// - Parameters:
    ///   - c: Array of constants to add
    public func bandjoinConst(c: [Double]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("c", value: c)
            opt.set("out", value: &out)

            try Self.call("bandjoin_const", options: &opt)
        }
    }

    /// Cast an image
    ///
    /// - Parameters:
    ///   - format: Format to cast to
    ///   - shift: Shift integer values up and down
    public func cast(format: VipsBandFormat, shift: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("format", value: format)
            if let shift = shift {
                opt.set("shift", value: shift)
            }
            opt.set("out", value: &out)

            try Self.call("cast", options: &opt)
        }
    }

    /// Blend a pair of images with a blend mode
    ///
    /// - Parameters:
    ///   - overlay: Overlay image
    ///   - mode: VipsBlendMode to join with
    ///   - x: x position of overlay
    ///   - y: y position of overlay
    ///   - compositingSpace: Composite images in this colour space
    ///   - premultiplied: Images have premultiplied alpha
    public func composite2(overlay: some VIPSImageProtocol, mode: VipsBlendMode, x: Int? = nil, y: Int? = nil, compositingSpace: VipsInterpretation? = nil, premultiplied: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("base", value: self)
            opt.set("overlay", value: overlay)
            opt.set("mode", value: mode)
            if let x = x {
                opt.set("x", value: x)
            }
            if let y = y {
                opt.set("y", value: y)
            }
            if let compositingSpace = compositingSpace {
                opt.set("compositing-space", value: compositingSpace)
            }
            if let premultiplied = premultiplied {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try Self.call("composite2", options: &opt)
        }
    }

    /// Copy an image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    ///   - format: Pixel format in image
    ///   - coding: Pixel coding
    ///   - interpretation: Pixel interpretation
    ///   - xres: Horizontal resolution in pixels/mm
    ///   - yres: Vertical resolution in pixels/mm
    ///   - xoffset: Horizontal offset of origin
    ///   - yoffset: Vertical offset of origin
    public func copy(width: Int? = nil, height: Int? = nil, bands: Int? = nil, format: VipsBandFormat? = nil, coding: VipsCoding? = nil, interpretation: VipsInterpretation? = nil, xres: Double? = nil, yres: Double? = nil, xoffset: Int? = nil, yoffset: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let width = width {
                opt.set("width", value: width)
            }
            if let height = height {
                opt.set("height", value: height)
            }
            if let bands = bands {
                opt.set("bands", value: bands)
            }
            if let format = format {
                opt.set("format", value: format)
            }
            if let coding = coding {
                opt.set("coding", value: coding)
            }
            if let interpretation = interpretation {
                opt.set("interpretation", value: interpretation)
            }
            if let xres = xres {
                opt.set("xres", value: xres)
            }
            if let yres = yres {
                opt.set("yres", value: yres)
            }
            if let xoffset = xoffset {
                opt.set("xoffset", value: xoffset)
            }
            if let yoffset = yoffset {
                opt.set("yoffset", value: yoffset)
            }
            opt.set("out", value: &out)

            try Self.call("copy", options: &opt)
        }
    }

    /// Embed an image in a larger image
    ///
    /// - Parameters:
    ///   - x: Left edge of input in output
    ///   - y: Top edge of input in output
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - extend: How to generate the extra pixels
    ///   - background: Color for background pixels
    public func embed(x: Int, y: Int, width: Int, height: Int, extend: VipsExtend? = nil, background: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("x", value: x)
            opt.set("y", value: y)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try Self.call("embed", options: &opt)
        }
    }

    /// Extract an area from an image
    ///
    /// - Parameters:
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func extractArea(`left`: Int, top: Int, width: Int, height: Int) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("input", value: self)
            opt.set("left", value: `left`)
            opt.set("top", value: top)
            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("out", value: &out)

            try Self.call("extract_area", options: &opt)
        }
    }

    /// Extract band from an image
    ///
    /// - Parameters:
    ///   - band: Band to extract
    ///   - n: Number of bands to extract
    public func extractBand(_ band: Int, n: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("band", value: band)
            if let n = n {
                opt.set("n", value: n)
            }
            opt.set("out", value: &out)

            try Self.call("extract_band", options: &opt)
        }
    }

    /// Flip an image
    ///
    /// - Parameters:
    ///   - direction: Direction to flip image
    public func flip(direction: VipsDirection) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("direction", value: direction)
            opt.set("out", value: &out)

            try Self.call("flip", options: &opt)
        }
    }

    /// Grid an image
    ///
    /// - Parameters:
    ///   - tileHeight: Chop into tiles this high
    ///   - across: Number of tiles across
    ///   - down: Number of tiles down
    public func grid(tileHeight: Int, across: Int, down: Int) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("tile-height", value: tileHeight)
            opt.set("across", value: across)
            opt.set("down", value: down)
            opt.set("out", value: &out)

            try Self.call("grid", options: &opt)
        }
    }

    /// Insert image @sub into @main at @x, @y
    ///
    /// - Parameters:
    ///   - sub: Sub-image to insert into main image
    ///   - x: Left edge of sub in main
    ///   - y: Top edge of sub in main
    ///   - expand: Expand output to hold all of both inputs
    ///   - background: Color for new pixels
    public func insert(sub: some VIPSImageProtocol, x: Int, y: Int, expand: Bool? = nil, background: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("main", value: self)
            opt.set("sub", value: sub)
            opt.set("x", value: x)
            opt.set("y", value: y)
            if let expand = expand {
                opt.set("expand", value: expand)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try Self.call("insert", options: &opt)
        }
    }

    /// Join a pair of images
    ///
    /// - Parameters:
    ///   - in2: Second input image
    ///   - direction: Join left-right or up-down
    ///   - expand: Expand output to hold all of both inputs
    ///   - shim: Pixels between images
    ///   - background: Colour for new pixels
    ///   - align: Align on the low, centre or high coordinate edge
    public func join(in2: some VIPSImageProtocol, direction: VipsDirection, expand: Bool? = nil, shim: Int? = nil, background: [Double]? = nil, align: VipsAlign? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in1", value: self)
            opt.set("in2", value: in2)
            opt.set("direction", value: direction)
            if let expand = expand {
                opt.set("expand", value: expand)
            }
            if let shim = shim {
                opt.set("shim", value: shim)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let align = align {
                opt.set("align", value: align)
            }
            opt.set("out", value: &out)

            try Self.call("join", options: &opt)
        }
    }

    /// Linear recombination with matrix
    ///
    /// - Parameters:
    ///   - m: Matrix of coefficients
    public func recomb(m: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("m", value: m)
            opt.set("out", value: &out)

            try Self.call("recomb", options: &opt)
        }
    }

    /// Reduce an image
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - vshrink: Vertical shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reduce(hshrink: Double, vshrink: Double, kernel: VipsKernel? = nil, gap: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("hshrink", value: hshrink)
            opt.set("vshrink", value: vshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if let gap = gap {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try Self.call("reduce", options: &opt)
        }
    }

    /// Shrink an image horizontally
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reduceh(hshrink: Double, kernel: VipsKernel? = nil, gap: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("hshrink", value: hshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if let gap = gap {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try Self.call("reduceh", options: &opt)
        }
    }

    /// Shrink an image vertically
    ///
    /// - Parameters:
    ///   - vshrink: Vertical shrink factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    public func reducev(vshrink: Double, kernel: VipsKernel? = nil, gap: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("vshrink", value: vshrink)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if let gap = gap {
                opt.set("gap", value: gap)
            }
            opt.set("out", value: &out)

            try Self.call("reducev", options: &opt)
        }
    }

    /// Resize an image
    ///
    /// - Parameters:
    ///   - scale: Scale image by this factor
    ///   - kernel: Resampling kernel
    ///   - gap: Reducing gap
    ///   - vscale: Vertical scale image by this factor
    public func resize(scale: Double, kernel: VipsKernel? = nil, gap: Double? = nil, vscale: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("scale", value: scale)
            if let kernel = kernel {
                opt.set("kernel", value: kernel)
            }
            if let gap = gap {
                opt.set("gap", value: gap)
            }
            if let vscale = vscale {
                opt.set("vscale", value: vscale)
            }
            opt.set("out", value: &out)

            try Self.call("resize", options: &opt)
        }
    }

    /// Rotate an image
    ///
    /// - Parameters:
    ///   - angle: Angle to rotate image
    public func rot(angle: VipsAngle) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("angle", value: angle)
            opt.set("out", value: &out)

            try Self.call("rot", options: &opt)
        }
    }

    /// Rotate an image
    ///
    /// - Parameters:
    ///   - angle: Angle to rotate image
    public func rot45(angle: VipsAngle45? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            opt.set("out", value: &out)

            try Self.call("rot45", options: &opt)
        }
    }

    /// Rotate an image by a number of degrees
    ///
    /// - Parameters:
    ///   - angle: Rotate clockwise by this many degrees
    ///   - interpolate: Interpolate pixels with this
    ///   - background: Background value
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    public func rotate(angle: Double, interpolate: VIPSInterpolate? = nil, background: [Double]? = nil, odx: Double? = nil, ody: Double? = nil, idx: Double? = nil, idy: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("angle", value: angle)
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let odx = odx {
                opt.set("odx", value: odx)
            }
            if let ody = ody {
                opt.set("ody", value: ody)
            }
            if let idx = idx {
                opt.set("idx", value: idx)
            }
            if let idy = idy {
                opt.set("idy", value: idy)
            }
            opt.set("out", value: &out)

            try Self.call("rotate", options: &opt)
        }
    }

    /// Scale an image to uchar
    ///
    /// - Parameters:
    ///   - exp: Exponent for log scale
    ///   - log: Log scale
    public func scale(exp: Double? = nil, log: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let exp = exp {
                opt.set("exp", value: exp)
            }
            if let log = log {
                opt.set("log", value: log)
            }
            opt.set("out", value: &out)

            try Self.call("scale", options: &opt)
        }
    }

    /// Shrink an image
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - vshrink: Vertical shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrink(hshrink: Double, vshrink: Double, ceil: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("hshrink", value: hshrink)
            opt.set("vshrink", value: vshrink)
            if let ceil = ceil {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try Self.call("shrink", options: &opt)
        }
    }

    /// Shrink an image horizontally
    ///
    /// - Parameters:
    ///   - hshrink: Horizontal shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrinkh(hshrink: Int, ceil: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("hshrink", value: hshrink)
            if let ceil = ceil {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try Self.call("shrinkh", options: &opt)
        }
    }

    /// Shrink an image vertically
    ///
    /// - Parameters:
    ///   - vshrink: Vertical shrink factor
    ///   - ceil: Round-up output dimensions
    public func shrinkv(vshrink: Int, ceil: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("vshrink", value: vshrink)
            if let ceil = ceil {
                opt.set("ceil", value: ceil)
            }
            opt.set("out", value: &out)

            try Self.call("shrinkv", options: &opt)
        }
    }

    /// Similarity transform of an image
    ///
    /// - Parameters:
    ///   - scale: Scale by this factor
    ///   - angle: Rotate clockwise by this many degrees
    ///   - interpolate: Interpolate pixels with this
    ///   - background: Background value
    ///   - odx: Horizontal output displacement
    ///   - ody: Vertical output displacement
    ///   - idx: Horizontal input displacement
    ///   - idy: Vertical input displacement
    public func similarity(scale: Double? = nil, angle: Double? = nil, interpolate: VIPSInterpolate? = nil, background: [Double]? = nil, odx: Double? = nil, ody: Double? = nil, idx: Double? = nil, idy: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let scale = scale {
                opt.set("scale", value: scale)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let odx = odx {
                opt.set("odx", value: odx)
            }
            if let ody = ody {
                opt.set("ody", value: ody)
            }
            if let idx = idx {
                opt.set("idx", value: idx)
            }
            if let idy = idy {
                opt.set("idy", value: idy)
            }
            opt.set("out", value: &out)

            try Self.call("similarity", options: &opt)
        }
    }

    /// Extract an area from an image
    ///
    /// - Parameters:
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    ///   - interesting: How to measure interestingness
    ///   - premultiplied: Input image already has premultiplied alpha
    public func smartcrop(width: Int, height: Int, interesting: VipsInteresting? = nil, premultiplied: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("input", value: self)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let interesting = interesting {
                opt.set("interesting", value: interesting)
            }
            if let premultiplied = premultiplied {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try Self.call("smartcrop", options: &opt)
        }
    }

    /// Cache an image as a set of tiles
    ///
    /// - Parameters:
    ///   - tileWidth: Tile width in pixels
    ///   - tileHeight: Tile height in pixels
    ///   - maxTiles: Maximum number of tiles to cache
    ///   - access: Expected access pattern
    ///   - threaded: Allow threaded access
    ///   - persistent: Keep cache between evaluations
    public func tilecache(tileWidth: Int? = nil, tileHeight: Int? = nil, maxTiles: Int? = nil, access: VipsAccess? = nil, threaded: Bool? = nil, persistent: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let tileWidth = tileWidth {
                opt.set("tile-width", value: tileWidth)
            }
            if let tileHeight = tileHeight {
                opt.set("tile-height", value: tileHeight)
            }
            if let maxTiles = maxTiles {
                opt.set("max-tiles", value: maxTiles)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let threaded = threaded {
                opt.set("threaded", value: threaded)
            }
            if let persistent = persistent {
                opt.set("persistent", value: persistent)
            }
            opt.set("out", value: &out)

            try Self.call("tilecache", options: &opt)
        }
    }

    /// Transpose3d an image
    ///
    /// - Parameters:
    ///   - pageHeight: Height of each input page
    public func transpose3d(pageHeight: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let pageHeight = pageHeight {
                opt.set("page-height", value: pageHeight)
            }
            opt.set("out", value: &out)

            try Self.call("transpose3d", options: &opt)
        }
    }

    /// Wrap image origin
    ///
    /// - Parameters:
    ///   - x: Left edge of input in output
    ///   - y: Top edge of input in output
    public func wrap(x: Int? = nil, y: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let x = x {
                opt.set("x", value: x)
            }
            if let y = y {
                opt.set("y", value: y)
            }
            opt.set("out", value: &out)

            try Self.call("wrap", options: &opt)
        }
    }

    /// Zoom an image
    ///
    /// - Parameters:
    ///   - xfac: Horizontal zoom factor
    ///   - yfac: Vertical zoom factor
    public func zoom(xfac: Int, yfac: Int) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("input", value: self)
            opt.set("xfac", value: xfac)
            opt.set("yfac", value: yfac)
            opt.set("out", value: &out)

            try Self.call("zoom", options: &opt)
        }
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Join an array of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - across: Number of images across grid
    ///   - shim: Pixels between images
    ///   - background: Colour for new pixels
    ///   - halign: Align on the left, centre or right
    ///   - valign: Align on the top, centre or bottom
    ///   - hspacing: Horizontal spacing between images
    ///   - vspacing: Vertical spacing between images
    public static func arrayjoin(_ `in`: [VIPSImage], across: Int? = nil, shim: Int? = nil, background: [Double]? = nil, halign: VipsAlign? = nil, valign: VipsAlign? = nil, hspacing: Int? = nil, vspacing: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            if let across = across {
                opt.set("across", value: across)
            }
            if let shim = shim {
                opt.set("shim", value: shim)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let halign = halign {
                opt.set("halign", value: halign)
            }
            if let valign = valign {
                opt.set("valign", value: valign)
            }
            if let hspacing = hspacing {
                opt.set("hspacing", value: hspacing)
            }
            if let vspacing = vspacing {
                opt.set("vspacing", value: vspacing)
            }
            opt.set("out", value: &out)

            try Self.call("arrayjoin", options: &opt)
        }
    }

    /// Bandwise join a set of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    public static func bandjoin(_ `in`: [VIPSImage]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("out", value: &out)

            try Self.call("bandjoin", options: &opt)
        }
    }

    /// Band-wise rank of a set of images
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - index: Select this band element from sorted list
    public static func bandrank(_ `in`: [VIPSImage], index: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            if let index = index {
                opt.set("index", value: index)
            }
            opt.set("out", value: &out)

            try Self.call("bandrank", options: &opt)
        }
    }

    /// Blend an array of images with an array of blend modes
    ///
    /// - Parameters:
    ///   - `in`: Array of input images
    ///   - mode: Array of VipsBlendMode to join with
    ///   - x: Array of x coordinates to join at
    ///   - y: Array of y coordinates to join at
    ///   - compositingSpace: Composite images in this colour space
    ///   - premultiplied: Images have premultiplied alpha
    public static func composite(_ `in`: [VIPSImage], mode: [Int], x: [Int]? = nil, y: [Int]? = nil, compositingSpace: VipsInterpretation? = nil, premultiplied: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: `in`)
            opt.set("mode", value: mode)
            if let x = x {
                opt.set("x", value: x)
            }
            if let y = y {
                opt.set("y", value: y)
            }
            if let compositingSpace = compositingSpace {
                opt.set("compositing-space", value: compositingSpace)
            }
            if let premultiplied = premultiplied {
                opt.set("premultiplied", value: premultiplied)
            }
            opt.set("out", value: &out)

            try Self.call("composite", options: &opt)
        }
    }

}

//
//  convolution.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Canny edge detector
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - precision: Convolve with this precision
    public func canny(sigma: Double? = nil, precision: VipsPrecision? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let sigma = sigma {
                opt.set("sigma", value: sigma)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try Self.call("canny", options: &opt)
        }
    }

    /// Convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func conv(mask: some VIPSImageProtocol, precision: VipsPrecision? = nil, layers: Int? = nil, cluster: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            if let cluster = cluster {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try Self.call("conv", options: &opt)
        }
    }

    /// Approximate integer convolution
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func conva(mask: some VIPSImageProtocol, layers: Int? = nil, cluster: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            if let cluster = cluster {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try Self.call("conva", options: &opt)
        }
    }

    /// Approximate separable integer convolution
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - layers: Use this many layers in approximation
    public func convasep(mask: some VIPSImageProtocol, layers: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            opt.set("out", value: &out)

            try Self.call("convasep", options: &opt)
        }
    }

    /// Float convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    public func convf(mask: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            opt.set("out", value: &out)

            try Self.call("convf", options: &opt)
        }
    }

    /// Int convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    public func convi(mask: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            opt.set("out", value: &out)

            try Self.call("convi", options: &opt)
        }
    }

    /// Separable convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func convsep(mask: some VIPSImageProtocol, precision: VipsPrecision? = nil, layers: Int? = nil, cluster: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            if let cluster = cluster {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try Self.call("convsep", options: &opt)
        }
    }

    /// Gaussian blur
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - precision: Convolve with this precision
    public func gaussblur(sigma: Double, minAmpl: Double? = nil, precision: VipsPrecision? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("sigma", value: sigma)
            if let minAmpl = minAmpl {
                opt.set("min-ampl", value: minAmpl)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try Self.call("gaussblur", options: &opt)
        }
    }

    /// Unsharp masking for print
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - x1: Flat/jaggy threshold
    ///   - y2: Maximum brightening
    ///   - y3: Maximum darkening
    ///   - m1: Slope for flat areas
    ///   - m2: Slope for jaggy areas
    public func sharpen(sigma: Double? = nil, x1: Double? = nil, y2: Double? = nil, y3: Double? = nil, m1: Double? = nil, m2: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let sigma = sigma {
                opt.set("sigma", value: sigma)
            }
            if let x1 = x1 {
                opt.set("x1", value: x1)
            }
            if let y2 = y2 {
                opt.set("y2", value: y2)
            }
            if let y3 = y3 {
                opt.set("y3", value: y3)
            }
            if let m1 = m1 {
                opt.set("m1", value: m1)
            }
            if let m2 = m2 {
                opt.set("m2", value: m2)
            }
            opt.set("out", value: &out)

            try Self.call("sharpen", options: &opt)
        }
    }

    /// Sobel edge detector
    public func sobel() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("sobel", options: &opt)
        }
    }

}

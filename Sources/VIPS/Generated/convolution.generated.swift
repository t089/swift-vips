//
//  convolution.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Canny edge detector
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - precision: Convolve with this precision
    public func canny(sigma: Double = 0.0, precision: VipsPrecision? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if sigma != 0.0 {
                opt.set("sigma", value: sigma)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("canny", options: &opt)
        }
    }

    /// Convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func conv(mask: VIPSImage, precision: VipsPrecision? = nil, layers: Int = 0, cluster: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if layers != 0 {
                opt.set("layers", value: layers)
            }
            if cluster != 0 {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("conv", options: &opt)
        }
    }

    /// Approximate integer convolution
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func conva(mask: VIPSImage, layers: Int = 0, cluster: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            if layers != 0 {
                opt.set("layers", value: layers)
            }
            if cluster != 0 {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("conva", options: &opt)
        }
    }

    /// Approximate separable integer convolution
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - layers: Use this many layers in approximation
    public func convasep(mask: VIPSImage, layers: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            if layers != 0 {
                opt.set("layers", value: layers)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("convasep", options: &opt)
        }
    }

    /// Float convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    public func convf(mask: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            opt.set("out", value: &out)

            try VIPSImage.call("convf", options: &opt)
        }
    }

    /// Int convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    public func convi(mask: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            opt.set("out", value: &out)

            try VIPSImage.call("convi", options: &opt)
        }
    }

    /// Separable convolution operation
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func convsep(mask: VIPSImage, precision: VipsPrecision? = nil, layers: Int = 0, cluster: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if layers != 0 {
                opt.set("layers", value: layers)
            }
            if cluster != 0 {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("convsep", options: &opt)
        }
    }

    /// Gaussian blur
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - precision: Convolve with this precision
    public func gaussblur(sigma: Double, minAmpl: Double = 0.0, precision: VipsPrecision? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("sigma", value: sigma)
            if minAmpl != 0.0 {
                opt.set("min_ampl", value: minAmpl)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gaussblur", options: &opt)
        }
    }

    /// Unsharp masking for print
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - x1: Flat/jaggy threshold
    ///   - y2: Maximum brightening
    ///   - y3: Maximum darkening
    ///   - m1: Slope for flat areas
    ///   - m2: Slope for jaggy areas
    public func sharpen(sigma: Double = 0.0, x1: Double = 0.0, y2: Double = 0.0, y3: Double = 0.0, m1: Double = 0.0, m2: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if sigma != 0.0 {
                opt.set("sigma", value: sigma)
            }
            if x1 != 0.0 {
                opt.set("x1", value: x1)
            }
            if y2 != 0.0 {
                opt.set("y2", value: y2)
            }
            if y3 != 0.0 {
                opt.set("y3", value: y3)
            }
            if m1 != 0.0 {
                opt.set("m1", value: m1)
            }
            if m2 != 0.0 {
                opt.set("m2", value: m2)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("sharpen", options: &opt)
        }
    }

    /// Sobel edge detector
    public func sobel() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("sobel", options: &opt)
        }
    }

}

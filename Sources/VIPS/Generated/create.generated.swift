//
//  create.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Make a black image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    public static func black(width: Int, height: Int, bands: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if bands != 0 {
                opt.set("bands", value: bands)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("black", options: &opt)
        }
    }

    /// Build a look-up table
    public func buildlut() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("buildlut", options: &opt)
        }
    }

    /// Make an image showing the eye's spatial response
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    ///   - factor: Maximum spatial frequency
    public static func eye(width: Int, height: Int, uchar: Bool = false, factor: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if factor != 0.0 {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("eye", options: &opt)
        }
    }

    /// Make a fractal surface
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - fractalDimension: Fractal dimension
    public static func fractsurf(width: Int, height: Int, fractalDimension: Double) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("fractal_dimension", value: fractalDimension)
            opt.set("out", value: &out)

            try VIPSImage.call("fractsurf", options: &opt)
        }
    }

    /// Make a gaussian image
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - separable: Generate separable Gaussian
    ///   - precision: Generate with this precision
    public static func gaussmat(sigma: Double, minAmpl: Double, separable: Bool = false, precision: VipsPrecision? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("sigma", value: sigma)
            opt.set("min_ampl", value: minAmpl)
            if separable != false {
                opt.set("separable", value: separable)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gaussmat", options: &opt)
        }
    }

    /// Make a gaussnoise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - sigma: Standard deviation of pixels in generated image
    ///   - mean: Mean of pixels in generated image
    ///   - seed: Random number seed
    public static func gaussnoise(width: Int, height: Int, sigma: Double = 0.0, mean: Double = 0.0, seed: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if sigma != 0.0 {
                opt.set("sigma", value: sigma)
            }
            if mean != 0.0 {
                opt.set("mean", value: mean)
            }
            if seed != 0 {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gaussnoise", options: &opt)
        }
    }

    /// Make a grey ramp image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    public static func grey(width: Int, height: Int, uchar: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("grey", options: &opt)
        }
    }

    /// Make a 1d image where pixel values are indexes
    ///
    /// - Parameters:
    ///   - bands: Number of bands in LUT
    ///   - ushort: Create a 16-bit LUT
    ///   - size: Size of 16-bit LUT
    public static func identity(bands: Int = 0, ushort: Bool = false, size: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            if bands != 0 {
                opt.set("bands", value: bands)
            }
            if ushort != false {
                opt.set("ushort", value: ushort)
            }
            if size != 0 {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("identity", options: &opt)
        }
    }

    /// Make a laplacian of gaussian image
    ///
    /// - Parameters:
    ///   - sigma: Radius of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - separable: Generate separable Gaussian
    ///   - precision: Generate with this precision
    public static func logmat(sigma: Double, minAmpl: Double, separable: Bool = false, precision: VipsPrecision? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("sigma", value: sigma)
            opt.set("min_ampl", value: minAmpl)
            if separable != false {
                opt.set("separable", value: separable)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("logmat", options: &opt)
        }
    }

    /// Make a butterworth filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworth(width: Int, height: Int, order: Double, frequencyCutoff: Double, amplitudeCutoff: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_butterworth", options: &opt)
        }
    }

    /// Make a butterworth_band filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworthBand(width: Int, height: Int, order: Double, frequencyCutoffX: Double, frequencyCutoffY: Double, radius: Double, amplitudeCutoff: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_butterworth_band", options: &opt)
        }
    }

    /// Make a butterworth ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworthRing(width: Int, height: Int, order: Double, frequencyCutoff: Double, amplitudeCutoff: Double, ringwidth: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            opt.set("ringwidth", value: ringwidth)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_butterworth_ring", options: &opt)
        }
    }

    /// Make fractal filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - fractalDimension: Fractal dimension
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskFractal(width: Int, height: Int, fractalDimension: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("fractal_dimension", value: fractalDimension)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_fractal", options: &opt)
        }
    }

    /// Make a gaussian filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussian(width: Int, height: Int, frequencyCutoff: Double, amplitudeCutoff: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_gaussian", options: &opt)
        }
    }

    /// Make a gaussian filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussianBand(width: Int, height: Int, frequencyCutoffX: Double, frequencyCutoffY: Double, radius: Double, amplitudeCutoff: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_gaussian_band", options: &opt)
        }
    }

    /// Make a gaussian ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussianRing(width: Int, height: Int, frequencyCutoff: Double, amplitudeCutoff: Double, ringwidth: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            opt.set("ringwidth", value: ringwidth)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_gaussian_ring", options: &opt)
        }
    }

    /// Make an ideal filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdeal(width: Int, height: Int, frequencyCutoff: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_ideal", options: &opt)
        }
    }

    /// Make an ideal band filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdealBand(width: Int, height: Int, frequencyCutoffX: Double, frequencyCutoffY: Double, radius: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_ideal_band", options: &opt)
        }
    }

    /// Make an ideal ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdealRing(width: Int, height: Int, frequencyCutoff: Double, ringwidth: Double, uchar: Bool = false, nodc: Bool = false, reject: Bool = false, optical: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("ringwidth", value: ringwidth)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if nodc != false {
                opt.set("nodc", value: nodc)
            }
            if reject != false {
                opt.set("reject", value: reject)
            }
            if optical != false {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mask_ideal_ring", options: &opt)
        }
    }

    /// Make a perlin noise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - cellSize: Size of Perlin cells
    ///   - uchar: Output an unsigned char image
    ///   - seed: Random number seed
    public static func perlin(width: Int, height: Int, cellSize: Int = 0, uchar: Bool = false, seed: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if cellSize != 0 {
                opt.set("cell_size", value: cellSize)
            }
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if seed != 0 {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("perlin", options: &opt)
        }
    }

    /// Make a 2d sine wave
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    ///   - hfreq: Horizontal spatial frequency
    ///   - vfreq: Vertical spatial frequency
    public static func sines(width: Int, height: Int, uchar: Bool = false, hfreq: Double = 0.0, vfreq: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            if hfreq != 0.0 {
                opt.set("hfreq", value: hfreq)
            }
            if vfreq != 0.0 {
                opt.set("vfreq", value: vfreq)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("sines", options: &opt)
        }
    }

    /// Make a text image
    ///
    /// - Parameters:
    ///   - text: Text to render
    ///   - font: Font to render with
    ///   - width: Maximum image width in pixels
    ///   - height: Maximum image height in pixels
    ///   - align: Align on the low, centre or high edge
    ///   - justify: Justify lines
    ///   - dpi: DPI to render at
    ///   - spacing: Line spacing
    ///   - fontfile: Load this font file
    ///   - rgba: Enable RGBA output
    ///   - wrap: Wrap lines on word or character boundaries
    public static func text(text: String, font: String = "", width: Int = 0, height: Int = 0, align: VipsAlign? = nil, justify: Bool = false, dpi: Int = 0, spacing: Int = 0, fontfile: String = "", rgba: Bool = false, wrap: VipsTextWrap? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("text", value: text)
            if font != "" {
                opt.set("font", value: font)
            }
            if width != 0 {
                opt.set("width", value: width)
            }
            if height != 0 {
                opt.set("height", value: height)
            }
            if let align = align {
                opt.set("align", value: align)
            }
            if justify != false {
                opt.set("justify", value: justify)
            }
            if dpi != 0 {
                opt.set("dpi", value: dpi)
            }
            if spacing != 0 {
                opt.set("spacing", value: spacing)
            }
            if fontfile != "" {
                opt.set("fontfile", value: fontfile)
            }
            if rgba != false {
                opt.set("rgba", value: rgba)
            }
            if let wrap = wrap {
                opt.set("wrap", value: wrap)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("text", options: &opt)
        }
    }

    /// Build a look-up table
    ///
    /// - Parameters:
    ///   - inMax: Size of LUT to build
    ///   - outMax: Maximum value in output LUT
    ///   - Lb: Lowest value in output
    ///   - Lw: Highest value in output
    ///   - Ps: Position of shadow
    ///   - Pm: Position of mid-tones
    ///   - Ph: Position of highlights
    ///   - S: Adjust shadows by this much
    ///   - M: Adjust mid-tones by this much
    ///   - H: Adjust highlights by this much
    public static func tonelut(inMax: Int = 0, outMax: Int = 0, Lb: Double = 0.0, Lw: Double = 0.0, Ps: Double = 0.0, Pm: Double = 0.0, Ph: Double = 0.0, S: Double = 0.0, M: Double = 0.0, H: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            if inMax != 0 {
                opt.set("in_max", value: inMax)
            }
            if outMax != 0 {
                opt.set("out_max", value: outMax)
            }
            if Lb != 0.0 {
                opt.set("Lb", value: Lb)
            }
            if Lw != 0.0 {
                opt.set("Lw", value: Lw)
            }
            if Ps != 0.0 {
                opt.set("Ps", value: Ps)
            }
            if Pm != 0.0 {
                opt.set("Pm", value: Pm)
            }
            if Ph != 0.0 {
                opt.set("Ph", value: Ph)
            }
            if S != 0.0 {
                opt.set("S", value: S)
            }
            if M != 0.0 {
                opt.set("M", value: M)
            }
            if H != 0.0 {
                opt.set("H", value: H)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("tonelut", options: &opt)
        }
    }

    /// Make a worley noise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - cellSize: Size of Worley cells
    ///   - seed: Random number seed
    public static func worley(width: Int, height: Int, cellSize: Int = 0, seed: Int = 0) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if cellSize != 0 {
                opt.set("cell_size", value: cellSize)
            }
            if seed != 0 {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("worley", options: &opt)
        }
    }

    /// Make a zone plate
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    public static func zone(width: Int, height: Int, uchar: Bool = false) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if uchar != false {
                opt.set("uchar", value: uchar)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("zone", options: &opt)
        }
    }

}

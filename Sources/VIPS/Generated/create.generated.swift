//
//  create.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Build a look-up table
    public func buildlut() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("buildlut", options: &opt)
        }
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Make a black image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - bands: Number of bands in image
    public static func black(width: Int, height: Int, bands: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let bands = bands {
                opt.set("bands", value: bands)
            }
            opt.set("out", value: &out)

            try Self.call("black", options: &opt)
        }
    }

    /// Make an image showing the eye's spatial response
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    ///   - factor: Maximum spatial frequency
    public static func eye(width: Int, height: Int, uchar: Bool? = nil, factor: Double? = nil)
        throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let factor = factor {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try Self.call("eye", options: &opt)
        }
    }

    /// Make a fractal surface
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - fractalDimension: Fractal dimension
    public static func fractsurf(width: Int, height: Int, fractalDimension: Double) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("fractal_dimension", value: fractalDimension)
            opt.set("out", value: &out)

            try Self.call("fractsurf", options: &opt)
        }
    }

    /// Make a gaussian image
    ///
    /// - Parameters:
    ///   - sigma: Sigma of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - separable: Generate separable Gaussian
    ///   - precision: Generate with this precision
    public static func gaussmat(
        sigma: Double,
        minAmpl: Double,
        separable: Bool? = nil,
        precision: VipsPrecision? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("sigma", value: sigma)
            opt.set("min_ampl", value: minAmpl)
            if let separable = separable {
                opt.set("separable", value: separable)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try Self.call("gaussmat", options: &opt)
        }
    }

    /// Make a gaussnoise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - sigma: Standard deviation of pixels in generated image
    ///   - mean: Mean of pixels in generated image
    ///   - seed: Random number seed
    public static func gaussnoise(
        width: Int,
        height: Int,
        sigma: Double? = nil,
        mean: Double? = nil,
        seed: Int? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let sigma = sigma {
                opt.set("sigma", value: sigma)
            }
            if let mean = mean {
                opt.set("mean", value: mean)
            }
            if let seed = seed {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try Self.call("gaussnoise", options: &opt)
        }
    }

    /// Make a grey ramp image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    public static func grey(width: Int, height: Int, uchar: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            opt.set("out", value: &out)

            try Self.call("grey", options: &opt)
        }
    }

    /// Make a 1D image where pixel values are indexes
    ///
    /// - Parameters:
    ///   - bands: Number of bands in LUT
    ///   - ushort: Create a 16-bit LUT
    ///   - size: Size of 16-bit LUT
    public static func identity(bands: Int? = nil, ushort: Bool? = nil, size: Int? = nil) throws
        -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            if let bands = bands {
                opt.set("bands", value: bands)
            }
            if let ushort = ushort {
                opt.set("ushort", value: ushort)
            }
            if let size = size {
                opt.set("size", value: size)
            }
            opt.set("out", value: &out)

            try Self.call("identity", options: &opt)
        }
    }

    /// Make a Laplacian of Gaussian image
    ///
    /// - Parameters:
    ///   - sigma: Radius of Gaussian
    ///   - minAmpl: Minimum amplitude of Gaussian
    ///   - separable: Generate separable Gaussian
    ///   - precision: Generate with this precision
    public static func logmat(
        sigma: Double,
        minAmpl: Double,
        separable: Bool? = nil,
        precision: VipsPrecision? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("sigma", value: sigma)
            opt.set("min_ampl", value: minAmpl)
            if let separable = separable {
                opt.set("separable", value: separable)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            opt.set("out", value: &out)

            try Self.call("logmat", options: &opt)
        }
    }

    /// Make a butterworth filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworth(
        width: Int,
        height: Int,
        order: Double,
        frequencyCutoff: Double,
        amplitudeCutoff: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_butterworth", options: &opt)
        }
    }

    /// Make a butterworth_band filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworthBand(
        width: Int,
        height: Int,
        order: Double,
        frequencyCutoffX: Double,
        frequencyCutoffY: Double,
        radius: Double,
        amplitudeCutoff: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_butterworth_band", options: &opt)
        }
    }

    /// Make a butterworth ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - order: Filter order
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskButterworthRing(
        width: Int,
        height: Int,
        order: Double,
        frequencyCutoff: Double,
        amplitudeCutoff: Double,
        ringwidth: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("order", value: order)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            opt.set("ringwidth", value: ringwidth)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_butterworth_ring", options: &opt)
        }
    }

    /// Make fractal filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - fractalDimension: Fractal dimension
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskFractal(
        width: Int,
        height: Int,
        fractalDimension: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("fractal_dimension", value: fractalDimension)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_fractal", options: &opt)
        }
    }

    /// Make a gaussian filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussian(
        width: Int,
        height: Int,
        frequencyCutoff: Double,
        amplitudeCutoff: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_gaussian", options: &opt)
        }
    }

    /// Make a gaussian filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussianBand(
        width: Int,
        height: Int,
        frequencyCutoffX: Double,
        frequencyCutoffY: Double,
        radius: Double,
        amplitudeCutoff: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_gaussian_band", options: &opt)
        }
    }

    /// Make a gaussian ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - amplitudeCutoff: Amplitude cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskGaussianRing(
        width: Int,
        height: Int,
        frequencyCutoff: Double,
        amplitudeCutoff: Double,
        ringwidth: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("amplitude_cutoff", value: amplitudeCutoff)
            opt.set("ringwidth", value: ringwidth)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_gaussian_ring", options: &opt)
        }
    }

    /// Make an ideal filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdeal(
        width: Int,
        height: Int,
        frequencyCutoff: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_ideal", options: &opt)
        }
    }

    /// Make an ideal band filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoffX: Frequency cutoff x
    ///   - frequencyCutoffY: Frequency cutoff y
    ///   - radius: Radius of circle
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdealBand(
        width: Int,
        height: Int,
        frequencyCutoffX: Double,
        frequencyCutoffY: Double,
        radius: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff_x", value: frequencyCutoffX)
            opt.set("frequency_cutoff_y", value: frequencyCutoffY)
            opt.set("radius", value: radius)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_ideal_band", options: &opt)
        }
    }

    /// Make an ideal ring filter
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - frequencyCutoff: Frequency cutoff
    ///   - ringwidth: Ringwidth
    ///   - uchar: Output an unsigned char image
    ///   - nodc: Remove DC component
    ///   - reject: Invert the sense of the filter
    ///   - optical: Rotate quadrants to optical space
    public static func maskIdealRing(
        width: Int,
        height: Int,
        frequencyCutoff: Double,
        ringwidth: Double,
        uchar: Bool? = nil,
        nodc: Bool? = nil,
        reject: Bool? = nil,
        optical: Bool? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("frequency_cutoff", value: frequencyCutoff)
            opt.set("ringwidth", value: ringwidth)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let nodc = nodc {
                opt.set("nodc", value: nodc)
            }
            if let reject = reject {
                opt.set("reject", value: reject)
            }
            if let optical = optical {
                opt.set("optical", value: optical)
            }
            opt.set("out", value: &out)

            try Self.call("mask_ideal_ring", options: &opt)
        }
    }

    /// Make a perlin noise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - cellSize: Size of Perlin cells
    ///   - uchar: Output an unsigned char image
    ///   - seed: Random number seed
    public static func perlin(
        width: Int,
        height: Int,
        cellSize: Int? = nil,
        uchar: Bool? = nil,
        seed: Int? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let cellSize = cellSize {
                opt.set("cell_size", value: cellSize)
            }
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let seed = seed {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try Self.call("perlin", options: &opt)
        }
    }

    /// Make a 2D sine wave
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    ///   - hfreq: Horizontal spatial frequency
    ///   - vfreq: Vertical spatial frequency
    public static func sines(
        width: Int,
        height: Int,
        uchar: Bool? = nil,
        hfreq: Double? = nil,
        vfreq: Double? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            if let hfreq = hfreq {
                opt.set("hfreq", value: hfreq)
            }
            if let vfreq = vfreq {
                opt.set("vfreq", value: vfreq)
            }
            opt.set("out", value: &out)

            try Self.call("sines", options: &opt)
        }
    }

    /// Make a text image
    ///
    /// - Parameters:
    ///   - text: Text to render
    ///   - font: Font to render with
    ///   - width: Maximum image width in pixels
    ///   - height: Maximum image height in pixels
    ///   - align: Align on the low, centre or high edge
    ///   - justify: Justify lines
    ///   - dpi: DPI to render at
    ///   - spacing: Line spacing
    ///   - fontfile: Load this font file
    ///   - rgba: Enable RGBA output
    ///   - wrap: Wrap lines on word or character boundaries
    public static func text(
        _ text: String,
        font: String? = nil,
        width: Int? = nil,
        height: Int? = nil,
        align: VipsAlign? = nil,
        justify: Bool? = nil,
        dpi: Int? = nil,
        spacing: Int? = nil,
        fontfile: String? = nil,
        rgba: Bool? = nil,
        wrap: VipsTextWrap? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("text", value: text)
            if let font = font {
                opt.set("font", value: font)
            }
            if let width = width {
                opt.set("width", value: width)
            }
            if let height = height {
                opt.set("height", value: height)
            }
            if let align = align {
                opt.set("align", value: align)
            }
            if let justify = justify {
                opt.set("justify", value: justify)
            }
            if let dpi = dpi {
                opt.set("dpi", value: dpi)
            }
            if let spacing = spacing {
                opt.set("spacing", value: spacing)
            }
            if let fontfile = fontfile {
                opt.set("fontfile", value: fontfile)
            }
            if let rgba = rgba {
                opt.set("rgba", value: rgba)
            }
            if let wrap = wrap {
                opt.set("wrap", value: wrap)
            }
            opt.set("out", value: &out)

            try Self.call("text", options: &opt)
        }
    }

    /// Build a look-up table
    ///
    /// - Parameters:
    ///   - inMax: Size of LUT to build
    ///   - outMax: Maximum value in output LUT
    ///   - Lb: Lowest value in output
    ///   - Lw: Highest value in output
    ///   - Ps: Position of shadow
    ///   - Pm: Position of mid-tones
    ///   - Ph: Position of highlights
    ///   - S: Adjust shadows by this much
    ///   - M: Adjust mid-tones by this much
    ///   - H: Adjust highlights by this much
    public static func tonelut(
        inMax: Int? = nil,
        outMax: Int? = nil,
        Lb: Double? = nil,
        Lw: Double? = nil,
        Ps: Double? = nil,
        Pm: Double? = nil,
        Ph: Double? = nil,
        S: Double? = nil,
        M: Double? = nil,
        H: Double? = nil
    ) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            if let inMax = inMax {
                opt.set("in_max", value: inMax)
            }
            if let outMax = outMax {
                opt.set("out_max", value: outMax)
            }
            if let Lb = Lb {
                opt.set("Lb", value: Lb)
            }
            if let Lw = Lw {
                opt.set("Lw", value: Lw)
            }
            if let Ps = Ps {
                opt.set("Ps", value: Ps)
            }
            if let Pm = Pm {
                opt.set("Pm", value: Pm)
            }
            if let Ph = Ph {
                opt.set("Ph", value: Ph)
            }
            if let S = S {
                opt.set("S", value: S)
            }
            if let M = M {
                opt.set("M", value: M)
            }
            if let H = H {
                opt.set("H", value: H)
            }
            opt.set("out", value: &out)

            try Self.call("tonelut", options: &opt)
        }
    }

    /// Make a worley noise image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - cellSize: Size of Worley cells
    ///   - seed: Random number seed
    public static func worley(width: Int, height: Int, cellSize: Int? = nil, seed: Int? = nil)
        throws -> Self
    {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let cellSize = cellSize {
                opt.set("cell_size", value: cellSize)
            }
            if let seed = seed {
                opt.set("seed", value: seed)
            }
            opt.set("out", value: &out)

            try Self.call("worley", options: &opt)
        }
    }

    /// Make a zone plate
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - uchar: Output an unsigned char image
    public static func zone(width: Int, height: Int, uchar: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            if let uchar = uchar {
                opt.set("uchar", value: uchar)
            }
            opt.set("out", value: &out)

            try Self.call("zone", options: &opt)
        }
    }

}

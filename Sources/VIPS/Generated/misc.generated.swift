//
//  misc.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Boolean operation across image bands
    ///
    /// - Parameters:
    ///   - boolean: Boolean to perform
    public func bandbool(boolean: VipsOperationBoolean) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("boolean", value: boolean)
            opt.set("out", value: &out)

            try VIPSImage.call("bandbool", options: &opt)
        }
    }

    /// Fold up x axis into bands
    ///
    /// - Parameters:
    ///   - factor: Fold by this factor
    public func bandfold(factor: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let factor = factor {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("bandfold", options: &opt)
        }
    }

    /// Band-wise average
    public func bandmean() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("bandmean", options: &opt)
        }
    }

    /// Unfold image bands into x axis
    ///
    /// - Parameters:
    ///   - factor: Unfold by this factor
    public func bandunfold(factor: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let factor = factor {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("bandunfold", options: &opt)
        }
    }

    /// Byteswap an image
    public func byteswap() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("byteswap", options: &opt)
        }
    }

    /// Use pixel values to pick cases from an array of images
    ///
    /// - Parameters:
    ///   - cases: Array of case images
    public func `case`(cases: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage([self, cases]) { out in
            var opt = VIPSOption()

            opt.set("index", value: self)
            opt.set("cases", value: cases)
            opt.set("out", value: &out)

            try VIPSImage.call("case", options: &opt)
        }
    }

    /// Clamp values of an image
    ///
    /// - Parameters:
    ///   - min: Minimum value
    ///   - max: Maximum value
    public func clamp(min: Double? = nil, max: Double? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let min = min {
                opt.set("min", value: min)
            }
            if let max = max {
                opt.set("max", value: max)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("clamp", options: &opt)
        }
    }

    /// Convolve with rotating mask
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - times: Rotate and convolve this many times
    ///   - angle: Rotate mask by this much between convolutions
    ///   - combine: Combine convolution results like this
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func compass(mask: VIPSImage, times: Int? = nil, angle: VipsAngle45? = nil, combine: VipsCombine? = nil, precision: VipsPrecision? = nil, layers: Int? = nil, cluster: Int? = nil) throws -> VIPSImage {
        return try VIPSImage([self, mask]) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let times = times {
                opt.set("times", value: times)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let combine = combine {
                opt.set("combine", value: combine)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            if let cluster = cluster {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("compass", options: &opt)
        }
    }

    /// Calculate de00
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE00(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("dE00", options: &opt)
        }
    }

    /// Calculate de76
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE76(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("dE76", options: &opt)
        }
    }

    /// Calculate decmc
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dECMC(_ rhs: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, rhs]) { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try VIPSImage.call("dECMC", options: &opt)
        }
    }

    /// Fast correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func fastcor(ref: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, ref]) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try VIPSImage.call("fastcor", options: &opt)
        }
    }

    /// Fill image zeros with nearest non-zero pixel
    public func fillNearest() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("fill_nearest", options: &opt)
        }
    }

    /// Search an image for non-edge areas
    ///
    /// - Parameters:
    ///   - threshold: Object threshold
    ///   - background: Color for background pixels
    ///   - lineArt: Enable line art mode
    public func findTrim(threshold: Double? = nil, background: [Double]? = nil, lineArt: Bool? = nil) throws -> Int {
        var opt = VIPSOption()

        var out: Int = 0

            opt.set("in", value: self.image)
            if let threshold = threshold {
                opt.set("threshold", value: threshold)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            if let lineArt = lineArt {
                opt.set("line_art", value: lineArt)
            }
            opt.set("left", value: &out)

            try VIPSImage.call("find_trim", options: &opt)

        return out
    }

    /// Flatten alpha out of an image
    ///
    /// - Parameters:
    ///   - background: Background value
    ///   - maxAlpha: Maximum value of alpha channel
    public func flatten(background: [Double]? = nil, maxAlpha: Double? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let background = background {
                opt.set("background", value: background)
            }
            if let maxAlpha = maxAlpha {
                opt.set("max_alpha", value: maxAlpha)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("flatten", options: &opt)
        }
    }

    /// Transform float rgb to radiance coding
    public func float2rad() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("float2rad", options: &opt)
        }
    }

    /// Gamma an image
    ///
    /// - Parameters:
    ///   - exponent: Gamma factor
    public func gamma(exponent: Double? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let exponent = exponent {
                opt.set("exponent", value: exponent)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gamma", options: &opt)
        }
    }

    /// Read a point from an image
    ///
    /// - Parameters:
    ///   - x: Point to read
    ///   - y: Point to read
    ///   - unpackComplex: Complex pixels should be unpacked
    public func getpoint(x: Int, y: Int, unpackComplex: Bool? = nil) throws -> [Double] {
        var opt = VIPSOption()

        var out: [Double] = []

            opt.set("in", value: self.image)
            opt.set("x", value: x)
            opt.set("y", value: y)
            if let unpackComplex = unpackComplex {
                opt.set("unpack_complex", value: unpackComplex)
            }
            opt.set("out_array", value: &out)

            try VIPSImage.call("getpoint", options: &opt)

        return out
    }

    /// Global balance an image mosaic
    ///
    /// - Parameters:
    ///   - gamma: Image gamma
    ///   - intOutput: Integer output
    public func globalbalance(gamma: Double? = nil, intOutput: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let gamma = gamma {
                opt.set("gamma", value: gamma)
            }
            if let intOutput = intOutput {
                opt.set("int_output", value: intOutput)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("globalbalance", options: &opt)
        }
    }

    /// Place an image within a larger image with a certain gravity
    ///
    /// - Parameters:
    ///   - direction: Direction to place image within width/height
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - extend: How to generate the extra pixels
    ///   - background: Color for background pixels
    public func gravity(direction: VipsCompassDirection, width: Int, height: Int, extend: VipsExtend? = nil, background: [Double]? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("direction", value: direction)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gravity", options: &opt)
        }
    }

    /// Ifthenelse an image
    ///
    /// - Parameters:
    ///   - in1: Source for TRUE pixels
    ///   - in2: Source for FALSE pixels
    ///   - blend: Blend smoothly between then and else parts
    public func ifthenelse(in1: VIPSImage, in2: VIPSImage, blend: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage([self, in1, in2]) { out in
            var opt = VIPSOption()

            opt.set("cond", value: self)
            opt.set("in1", value: in1)
            opt.set("in2", value: in2)
            if let blend = blend {
                opt.set("blend", value: blend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ifthenelse", options: &opt)
        }
    }

    /// Cache an image as a set of lines
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    ///   - access: Expected access pattern
    ///   - threaded: Allow threaded access
    ///   - persistent: Keep cache between evaluations
    public func linecache(tileHeight: Int? = nil, access: VipsAccess? = nil, threaded: Bool? = nil, persistent: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let threaded = threaded {
                opt.set("threaded", value: threaded)
            }
            if let persistent = persistent {
                opt.set("persistent", value: persistent)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("linecache", options: &opt)
        }
    }

    /// Map an image though a lut
    ///
    /// - Parameters:
    ///   - lut: Look-up table image
    ///   - band: Apply one-band lut to this band of in
    public func maplut(lut: VIPSImage, band: Int? = nil) throws -> VIPSImage {
        return try VIPSImage([self, lut]) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("lut", value: lut)
            if let band = band {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("maplut", options: &opt)
        }
    }

    /// First-order match of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    public func match(sec: VIPSImage, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int? = nil, harea: Int? = nil, search: Bool? = nil, interpolate: VIPSInterpolate? = nil) throws -> VIPSImage {
        return try VIPSImage([self, sec, interpolate as Any]) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let search = search {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("match", options: &opt)
        }
    }

    /// Measure a set of patches on a color chart
    ///
    /// - Parameters:
    ///   - h: Number of patches across chart
    ///   - v: Number of patches down chart
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func measure(h: Int, v: Int, `left`: Int? = nil, top: Int? = nil, width: Int? = nil, height: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("h", value: h)
            opt.set("v", value: v)
            if let `left` = `left` {
                opt.set("left", value: `left`)
            }
            if let top = top {
                opt.set("top", value: top)
            }
            if let width = width {
                opt.set("width", value: width)
            }
            if let height = height {
                opt.set("height", value: height)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("measure", options: &opt)
        }
    }

    /// Merge two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical merge
    ///   - dx: Horizontal displacement from sec to ref
    ///   - dy: Vertical displacement from sec to ref
    ///   - mblend: Maximum blend size
    public func merge(sec: VIPSImage, direction: VipsDirection, dx: Int, dy: Int, mblend: Int? = nil) throws -> VIPSImage {
        return try VIPSImage([self, sec]) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("dx", value: dx)
            opt.set("dy", value: dy)
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("merge", options: &opt)
        }
    }

    /// Mosaic two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xref: Position of reference tie-point
    ///   - yref: Position of reference tie-point
    ///   - xsec: Position of secondary tie-point
    ///   - ysec: Position of secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - mblend: Maximum blend size
    ///   - bandno: Band to search for features on
    public func mosaic(sec: VIPSImage, direction: VipsDirection, xref: Int, yref: Int, xsec: Int, ysec: Int, hwindow: Int? = nil, harea: Int? = nil, mblend: Int? = nil, bandno: Int? = nil) throws -> VIPSImage {
        return try VIPSImage([self, sec]) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xref", value: xref)
            opt.set("yref", value: yref)
            opt.set("xsec", value: xsec)
            opt.set("ysec", value: ysec)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            if let bandno = bandno {
                opt.set("bandno", value: bandno)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mosaic", options: &opt)
        }
    }

    /// First-order mosaic of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    ///   - mblend: Maximum blend size
    public func mosaic1(sec: VIPSImage, direction: VipsDirection, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int? = nil, harea: Int? = nil, search: Bool? = nil, interpolate: VIPSInterpolate? = nil, mblend: Int? = nil) throws -> VIPSImage {
        return try VIPSImage([self, sec, interpolate as Any]) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let search = search {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mosaic1", options: &opt)
        }
    }

    /// Pick most-significant byte from an image
    ///
    /// - Parameters:
    ///   - band: Band to msb
    public func msb(band: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let band = band {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("msb", options: &opt)
        }
    }

    /// Find threshold for percent of pixels
    ///
    /// - Parameters:
    ///   - percent: Percent of pixels
    public func percent(_ percent: Double) throws -> Int {
        var opt = VIPSOption()

        var out: Int = 0

            opt.set("in", value: self.image)
            opt.set("percent", value: percent)
            opt.set("threshold", value: &out)

            try VIPSImage.call("percent", options: &opt)

        return out
    }

    /// Prewitt edge detector
    public func prewitt() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("prewitt", options: &opt)
        }
    }

    /// Unpack radiance coding to float rgb
    public func rad2float() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("rad2float", options: &opt)
        }
    }

    /// Replicate an image
    ///
    /// - Parameters:
    ///   - across: Repeat this many times horizontally
    ///   - down: Repeat this many times vertically
    public func replicate(across: Int, down: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("across", value: across)
            opt.set("down", value: down)
            opt.set("out", value: &out)

            try VIPSImage.call("replicate", options: &opt)
        }
    }

    /// Scharr edge detector
    public func scharr() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try VIPSImage.call("scharr", options: &opt)
        }
    }

    /// Create an sdf image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - shape: SDF shape to create
    ///   - r: Radius
    ///   - a: Point a
    ///   - b: Point b
    ///   - corners: Corner radii
    public static func sdf(width: Int, height: Int, shape: VipsSdfShape, r: Double? = nil, a: [Double]? = nil, b: [Double]? = nil, corners: [Double]? = nil) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("shape", value: shape)
            if let r = r {
                opt.set("r", value: r)
            }
            if let a = a {
                opt.set("a", value: a)
            }
            if let b = b {
                opt.set("b", value: b)
            }
            if let corners = corners {
                opt.set("corners", value: corners)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("sdf", options: &opt)
        }
    }

    /// Check sequential access
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    public func sequential(tileHeight: Int? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let tileHeight = tileHeight {
                opt.set("tile_height", value: tileHeight)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("sequential", options: &opt)
        }
    }

    /// Spatial correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func spcor(ref: VIPSImage) throws -> VIPSImage {
        return try VIPSImage([self, ref]) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try VIPSImage.call("spcor", options: &opt)
        }
    }

    /// Statistical difference
    ///
    /// - Parameters:
    ///   - width: Window width in pixels
    ///   - height: Window height in pixels
    ///   - s0: New deviation
    ///   - b: Weight of new deviation
    ///   - m0: New mean
    ///   - a: Weight of new mean
    public func stdif(width: Int, height: Int, s0: Double? = nil, b: Double? = nil, m0: Double? = nil, a: Double? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let s0 = s0 {
                opt.set("s0", value: s0)
            }
            if let b = b {
                opt.set("b", value: b)
            }
            if let m0 = m0 {
                opt.set("m0", value: m0)
            }
            if let a = a {
                opt.set("a", value: a)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("stdif", options: &opt)
        }
    }

    /// Subsample an image
    ///
    /// - Parameters:
    ///   - xfac: Horizontal subsample factor
    ///   - yfac: Vertical subsample factor
    ///   - point: Point sample
    public func subsample(xfac: Int, yfac: Int, point: Bool? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self)
            opt.set("xfac", value: xfac)
            opt.set("yfac", value: yfac)
            if let point = point {
                opt.set("point", value: point)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("subsample", options: &opt)
        }
    }

    /// Find the index of the first non-zero pixel in tests
    ///
    /// - Parameters:
    ///   - tests: Table of images to test
    public static func `switch`(tests: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage([tests]) { out in
            var opt = VIPSOption()

            opt.set("tests", value: tests)
            opt.set("out", value: &out)

            try VIPSImage.call("switch", options: &opt)
        }
    }

}

//
//  misc.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips

extension VIPSImage {

    /// Boolean operation across image bands
    ///
    /// - Parameters:
    ///   - boolean: Boolean to perform
    public func bandbool(boolean: VipsOperationBoolean) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("boolean", value: boolean)
            opt.set("out", value: &out)

            try VIPSImage.call("bandbool", options: &opt)
        }
    }

    /// Fold up x axis into bands
    ///
    /// - Parameters:
    ///   - factor: Fold by this factor
    public func bandfold(factor: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if factor != 0 {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("bandfold", options: &opt)
        }
    }

    /// Band-wise average
    public func bandmean() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("bandmean", options: &opt)
        }
    }

    /// Unfold image bands into x axis
    ///
    /// - Parameters:
    ///   - factor: Unfold by this factor
    public func bandunfold(factor: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if factor != 0 {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("bandunfold", options: &opt)
        }
    }

    /// Byteswap an image
    public func byteswap() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("byteswap", options: &opt)
        }
    }

    /// Cache an image
    ///
    /// - Parameters:
    ///   - maxTiles: Maximum number of tiles to cache
    ///   - tileHeight: Tile height in pixels
    ///   - tileWidth: Tile width in pixels
    public func cache(maxTiles: Int = 0, tileHeight: Int = 0, tileWidth: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if maxTiles != 0 {
                opt.set("max_tiles", value: maxTiles)
            }
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if tileWidth != 0 {
                opt.set("tile_width", value: tileWidth)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("cache", options: &opt)
        }
    }

    /// Use pixel values to pick cases from an array of images
    ///
    /// - Parameters:
    ///   - cases: Array of case images
    public func case(cases: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("index", value: self.image)
            opt.set("cases", value: cases)
            opt.set("out", value: &out)

            try VIPSImage.call("case", options: &opt)
        }
    }

    /// Convolve with rotating mask
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - times: Rotate and convolve this many times
    ///   - angle: Rotate mask by this much between convolutions
    ///   - combine: Combine convolution results like this
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func compass(mask: VIPSImage, times: Int = 0, angle: VipsAngle45? = nil, combine: VipsCombine? = nil, precision: VipsPrecision? = nil, layers: Int = 0, cluster: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("mask", value: mask)
            if times != 0 {
                opt.set("times", value: times)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let combine = combine {
                opt.set("combine", value: combine)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if layers != 0 {
                opt.set("layers", value: layers)
            }
            if cluster != 0 {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("compass", options: &opt)
        }
    }

    /// Calculate de00
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE00(`right`: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("left", value: self.image)
            opt.set("right", value: `right`)
            opt.set("out", value: &out)

            try VIPSImage.call("dE00", options: &opt)
        }
    }

    /// Calculate de76
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE76(`right`: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("left", value: self.image)
            opt.set("right", value: `right`)
            opt.set("out", value: &out)

            try VIPSImage.call("dE76", options: &opt)
        }
    }

    /// Calculate decmc
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dECMC(`right`: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("left", value: self.image)
            opt.set("right", value: `right`)
            opt.set("out", value: &out)

            try VIPSImage.call("dECMC", options: &opt)
        }
    }

    /// Fast correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func fastcor(ref: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try VIPSImage.call("fastcor", options: &opt)
        }
    }

    /// Fill image zeros with nearest non-zero pixel
    public func fillNearest() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("fill_nearest", options: &opt)
        }
    }

    /// Search an image for non-edge areas
    ///
    /// - Parameters:
    ///   - threshold: Object threshold
    ///   - background: Color for background pixels
    ///   - lineArt: Enable line art mode
    public func findTrim(threshold: Double = 0.0, background: [Double] = [], lineArt: Bool = false) throws -> Int {
        try VIPSImage.execute {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if threshold != 0.0 {
                opt.set("threshold", value: threshold)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            if lineArt != false {
                opt.set("line_art", value: lineArt)
            }

            try VIPSImage.call("find_trim", options: &opt)
        }
    }

    /// Flatten alpha out of an image
    ///
    /// - Parameters:
    ///   - background: Background value
    ///   - maxAlpha: Maximum value of alpha channel
    public func flatten(background: [Double] = [], maxAlpha: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if background != [] {
                opt.set("background", value: background)
            }
            if maxAlpha != 0.0 {
                opt.set("max_alpha", value: maxAlpha)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("flatten", options: &opt)
        }
    }

    /// Transform float rgb to radiance coding
    public func float2rad() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("float2rad", options: &opt)
        }
    }

    /// Gamma an image
    ///
    /// - Parameters:
    ///   - exponent: Gamma factor
    public func gamma(exponent: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if exponent != 0.0 {
                opt.set("exponent", value: exponent)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gamma", options: &opt)
        }
    }

    /// Read a point from an image
    ///
    /// - Parameters:
    ///   - x: Point to read
    ///   - y: Point to read
    public func getpoint(x: Int, y: Int) throws -> [Double] {
        try VIPSImage.execute {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("x", value: x)
            opt.set("y", value: y)

            try VIPSImage.call("getpoint", options: &opt)
        }
    }

    /// Global balance an image mosaic
    ///
    /// - Parameters:
    ///   - gamma: Image gamma
    ///   - intOutput: Integer output
    public func globalbalance(gamma: Double = 0.0, intOutput: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if gamma != 0.0 {
                opt.set("gamma", value: gamma)
            }
            if intOutput != false {
                opt.set("int_output", value: intOutput)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("globalbalance", options: &opt)
        }
    }

    /// Place an image within a larger image with a certain gravity
    ///
    /// - Parameters:
    ///   - direction: Direction to place image within width/height
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - extend: How to generate the extra pixels
    ///   - background: Color for background pixels
    public func gravity(direction: VipsCompassDirection, width: Int, height: Int, extend: VipsExtend? = nil, background: [Double] = []) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("direction", value: direction)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            if background != [] {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("gravity", options: &opt)
        }
    }

    /// Ifthenelse an image
    ///
    /// - Parameters:
    ///   - in1: Source for TRUE pixels
    ///   - in2: Source for FALSE pixels
    ///   - blend: Blend smoothly between then and else parts
    public func ifthenelse(in1: VIPSImage, in2: VIPSImage, blend: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("cond", value: self.image)
            opt.set("in1", value: in1)
            opt.set("in2", value: in2)
            if blend != false {
                opt.set("blend", value: blend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("ifthenelse", options: &opt)
        }
    }

    /// Cache an image as a set of lines
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    ///   - access: Expected access pattern
    ///   - threaded: Allow threaded access
    ///   - persistent: Keep cache between evaluations
    public func linecache(tileHeight: Int = 0, access: VipsAccess? = nil, threaded: Bool = false, persistent: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if threaded != false {
                opt.set("threaded", value: threaded)
            }
            if persistent != false {
                opt.set("persistent", value: persistent)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("linecache", options: &opt)
        }
    }

    /// Map an image though a lut
    ///
    /// - Parameters:
    ///   - lut: Look-up table image
    ///   - band: Apply one-band lut to this band of in
    public func maplut(lut: VIPSImage, band: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("lut", value: lut)
            if band != 0 {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("maplut", options: &opt)
        }
    }

    /// First-order match of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    public func match(sec: VIPSImage, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int = 0, harea: Int = 0, search: Bool = false, interpolate: VIPSInterpolate? = nil) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self.image)
            opt.set("sec", value: sec)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if hwindow != 0 {
                opt.set("hwindow", value: hwindow)
            }
            if harea != 0 {
                opt.set("harea", value: harea)
            }
            if search != false {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("match", options: &opt)
        }
    }

    /// Measure a set of patches on a color chart
    ///
    /// - Parameters:
    ///   - h: Number of patches across chart
    ///   - v: Number of patches down chart
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func measure(h: Int, v: Int, `left`: Int = 0, top: Int = 0, width: Int = 0, height: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("h", value: h)
            opt.set("v", value: v)
            if `left` != 0 {
                opt.set("left", value: `left`)
            }
            if top != 0 {
                opt.set("top", value: top)
            }
            if width != 0 {
                opt.set("width", value: width)
            }
            if height != 0 {
                opt.set("height", value: height)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("measure", options: &opt)
        }
    }

    /// Merge two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical merge
    ///   - dx: Horizontal displacement from sec to ref
    ///   - dy: Vertical displacement from sec to ref
    ///   - mblend: Maximum blend size
    public func merge(sec: VIPSImage, direction: VipsDirection, dx: Int, dy: Int, mblend: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self.image)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("dx", value: dx)
            opt.set("dy", value: dy)
            if mblend != 0 {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("merge", options: &opt)
        }
    }

    /// Mosaic two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xref: Position of reference tie-point
    ///   - yref: Position of reference tie-point
    ///   - xsec: Position of secondary tie-point
    ///   - ysec: Position of secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - mblend: Maximum blend size
    ///   - bandno: Band to search for features on
    public func mosaic(sec: VIPSImage, direction: VipsDirection, xref: Int, yref: Int, xsec: Int, ysec: Int, hwindow: Int = 0, harea: Int = 0, mblend: Int = 0, bandno: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self.image)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xref", value: xref)
            opt.set("yref", value: yref)
            opt.set("xsec", value: xsec)
            opt.set("ysec", value: ysec)
            if hwindow != 0 {
                opt.set("hwindow", value: hwindow)
            }
            if harea != 0 {
                opt.set("harea", value: harea)
            }
            if mblend != 0 {
                opt.set("mblend", value: mblend)
            }
            if bandno != 0 {
                opt.set("bandno", value: bandno)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mosaic", options: &opt)
        }
    }

    /// First-order mosaic of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    ///   - mblend: Maximum blend size
    public func mosaic1(sec: VIPSImage, direction: VipsDirection, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int = 0, harea: Int = 0, search: Bool = false, interpolate: VIPSInterpolate? = nil, mblend: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("ref", value: self.image)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if hwindow != 0 {
                opt.set("hwindow", value: hwindow)
            }
            if harea != 0 {
                opt.set("harea", value: harea)
            }
            if search != false {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if mblend != 0 {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("mosaic1", options: &opt)
        }
    }

    /// Pick most-significant byte from an image
    ///
    /// - Parameters:
    ///   - band: Band to msb
    public func msb(band: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if band != 0 {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("msb", options: &opt)
        }
    }

    /// Find threshold for percent of pixels
    ///
    /// - Parameters:
    ///   - percent: Percent of pixels
    public func percent(percent: Double) throws -> Int {
        try VIPSImage.execute {
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("percent", value: percent)

            try VIPSImage.call("percent", options: &opt)
        }
    }

    /// Prewitt edge detector
    public func prewitt() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("prewitt", options: &opt)
        }
    }

    /// Unpack radiance coding to float rgb
    public func rad2float() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("rad2float", options: &opt)
        }
    }

    /// Replicate an image
    ///
    /// - Parameters:
    ///   - across: Repeat this many times horizontally
    ///   - down: Repeat this many times vertically
    public func replicate(across: Int, down: Int) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("across", value: across)
            opt.set("down", value: down)
            opt.set("out", value: &out)

            try VIPSImage.call("replicate", options: &opt)
        }
    }

    /// Scharr edge detector
    public func scharr() throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("out", value: &out)

            try VIPSImage.call("scharr", options: &opt)
        }
    }

    /// Check sequential access
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    public func sequential(tileHeight: Int = 0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            if tileHeight != 0 {
                opt.set("tile_height", value: tileHeight)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("sequential", options: &opt)
        }
    }

    /// Spatial correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func spcor(ref: VIPSImage) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try VIPSImage.call("spcor", options: &opt)
        }
    }

    /// Statistical difference
    ///
    /// - Parameters:
    ///   - width: Window width in pixels
    ///   - height: Window height in pixels
    ///   - s0: New deviation
    ///   - b: Weight of new deviation
    ///   - m0: New mean
    ///   - a: Weight of new mean
    public func stdif(width: Int, height: Int, s0: Double = 0.0, b: Double = 0.0, m0: Double = 0.0, a: Double = 0.0) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("in", value: self.image)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if s0 != 0.0 {
                opt.set("s0", value: s0)
            }
            if b != 0.0 {
                opt.set("b", value: b)
            }
            if m0 != 0.0 {
                opt.set("m0", value: m0)
            }
            if a != 0.0 {
                opt.set("a", value: a)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("stdif", options: &opt)
        }
    }

    /// Subsample an image
    ///
    /// - Parameters:
    ///   - xfac: Horizontal subsample factor
    ///   - yfac: Vertical subsample factor
    ///   - point: Point sample
    public func subsample(xfac: Int, yfac: Int, point: Bool = false) throws -> VIPSImage {
        return try VIPSImage(self) { out in
            var opt = VIPSOption()

            opt.set("input", value: self.image)
            opt.set("xfac", value: xfac)
            opt.set("yfac", value: yfac)
            if point != false {
                opt.set("point", value: point)
            }
            opt.set("out", value: &out)

            try VIPSImage.call("subsample", options: &opt)
        }
    }

    /// Find the index of the first non-zero pixel in tests
    ///
    /// - Parameters:
    ///   - tests: Table of images to test
    public static func switch(tests: [VIPSImage]) throws -> VIPSImage {
        return try VIPSImage(nil) { out in
            var opt = VIPSOption()

            opt.set("tests", value: tests)
            opt.set("out", value: &out)

            try VIPSImage.call("switch", options: &opt)
        }
    }

}

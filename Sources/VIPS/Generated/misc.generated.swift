//
//  misc.generated.swift
//
//  Generated by VIPS Swift Code Generator
//  DO NOT EDIT - This file is automatically generated
//

import Cvips
import CvipsShim

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

    /// Boolean operation across image bands
    ///
    /// - Parameters:
    ///   - boolean: Boolean to perform
    public func bandbool(boolean: VipsOperationBoolean) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("boolean", value: boolean)
            opt.set("out", value: &out)

            try Self.call("bandbool", options: &opt)
        }
    }

    /// Fold up x axis into bands
    ///
    /// - Parameters:
    ///   - factor: Fold by this factor
    public func bandfold(factor: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let factor = factor {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try Self.call("bandfold", options: &opt)
        }
    }

    /// Band-wise average
    public func bandmean() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("bandmean", options: &opt)
        }
    }

    /// Unfold image bands into x axis
    ///
    /// - Parameters:
    ///   - factor: Unfold by this factor
    public func bandunfold(factor: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let factor = factor {
                opt.set("factor", value: factor)
            }
            opt.set("out", value: &out)

            try Self.call("bandunfold", options: &opt)
        }
    }

    /// Byteswap an image
    public func byteswap() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("byteswap", options: &opt)
        }
    }

    /// Use pixel values to pick cases from an array of images
    ///
    /// - Parameters:
    ///   - cases: Array of case images
    public func `case`(cases: [VIPSImage]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("index", value: self)
            opt.set("cases", value: cases)
            opt.set("out", value: &out)

            try Self.call("case", options: &opt)
        }
    }

    /// Clamp values of an image
    ///
    /// - Parameters:
    ///   - min: Minimum value
    ///   - max: Maximum value
    public func clamp(min: Double? = nil, max: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let min = min {
                opt.set("min", value: min)
            }
            if let max = max {
                opt.set("max", value: max)
            }
            opt.set("out", value: &out)

            try Self.call("clamp", options: &opt)
        }
    }

    /// Convolve with rotating mask
    ///
    /// - Parameters:
    ///   - mask: Input matrix image
    ///   - times: Rotate and convolve this many times
    ///   - angle: Rotate mask by this much between convolutions
    ///   - combine: Combine convolution results like this
    ///   - precision: Convolve with this precision
    ///   - layers: Use this many layers in approximation
    ///   - cluster: Cluster lines closer than this in approximation
    public func compass(mask: some VIPSImageProtocol, times: Int? = nil, angle: VipsAngle45? = nil, combine: VipsCombine? = nil, precision: VipsPrecision? = nil, layers: Int? = nil, cluster: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("mask", value: mask)
            if let times = times {
                opt.set("times", value: times)
            }
            if let angle = angle {
                opt.set("angle", value: angle)
            }
            if let combine = combine {
                opt.set("combine", value: combine)
            }
            if let precision = precision {
                opt.set("precision", value: precision)
            }
            if let layers = layers {
                opt.set("layers", value: layers)
            }
            if let cluster = cluster {
                opt.set("cluster", value: cluster)
            }
            opt.set("out", value: &out)

            try Self.call("compass", options: &opt)
        }
    }

    /// Calculate dE00
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE00(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("dE00", options: &opt)
        }
    }

    /// Calculate dE76
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dE76(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("dE76", options: &opt)
        }
    }

    /// Calculate dECMC
    ///
    /// - Parameters:
    ///   - `right`: Right-hand input image
    public func dECMC(_ rhs: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("left", value: self)
            opt.set("right", value: rhs)
            opt.set("out", value: &out)

            try Self.call("dECMC", options: &opt)
        }
    }

    /// Fast correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func fastcor(ref: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try Self.call("fastcor", options: &opt)
        }
    }

    /// Fill image zeros with nearest non-zero pixel
    public func fillNearest() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("fill_nearest", options: &opt)
        }
    }

    /// Search an image for non-edge areas
    ///
    /// - Parameters:
    ///   - threshold: Object threshold
    ///   - background: Color for background pixels
    ///   - lineArt: Enable line art mode
    public func findTrim(threshold: Double? = nil, background: [Double]? = nil, lineArt: Bool? = nil) throws -> Int {
        var opt = VIPSOption()

        var out: Int = 0

        opt.set("in", value: self.image)
        if let threshold = threshold {
            opt.set("threshold", value: threshold)
        }
        if let background = background {
            opt.set("background", value: background)
        }
        if let lineArt = lineArt {
            opt.set("line-art", value: lineArt)
        }
        opt.set("left", value: &out)

        try Self.call("find_trim", options: &opt)

        return out
    }

    /// Flatten alpha out of an image
    ///
    /// - Parameters:
    ///   - background: Background value
    ///   - maxAlpha: Maximum value of alpha channel
    public func flatten(background: [Double]? = nil, maxAlpha: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let background = background {
                opt.set("background", value: background)
            }
            if let maxAlpha = maxAlpha {
                opt.set("max-alpha", value: maxAlpha)
            }
            opt.set("out", value: &out)

            try Self.call("flatten", options: &opt)
        }
    }

    /// Transform float RGB to Radiance coding
    public func float2rad() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("float2rad", options: &opt)
        }
    }

    /// Gamma an image
    ///
    /// - Parameters:
    ///   - exponent: Gamma factor
    public func gamma(exponent: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let exponent = exponent {
                opt.set("exponent", value: exponent)
            }
            opt.set("out", value: &out)

            try Self.call("gamma", options: &opt)
        }
    }

    /// Read a point from an image
    ///
    /// - Parameters:
    ///   - x: Point to read
    ///   - y: Point to read
    ///   - unpackComplex: Complex pixels should be unpacked
    public func getpoint(x: Int, y: Int, unpackComplex: Bool? = nil) throws -> [Double] {
        var opt = VIPSOption()

        var out: UnsafeMutablePointer<VipsArrayDouble>! = .allocate(capacity: 1)

        opt.set("in", value: self.image)
        opt.set("x", value: x)
        opt.set("y", value: y)
        if let unpackComplex = unpackComplex {
            opt.set("unpack-complex", value: unpackComplex)
        }
        opt.set("out-array", value: &out)

        try Self.call("getpoint", options: &opt)

        guard let out else {
            throw VIPSError("getpoint: no output")
        }

        defer {
            vips_area_unref(shim_vips_area(out))
        }
        
        var length = Int32(0)
        let doubles = vips_array_double_get(out, &length)
        let buffer = UnsafeBufferPointer(start: doubles, count: Int(length))
        return Array(buffer)
    }

    /// Global balance an image mosaic
    ///
    /// - Parameters:
    ///   - gamma: Image gamma
    ///   - intOutput: Integer output
    public func globalbalance(gamma: Double? = nil, intOutput: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let gamma = gamma {
                opt.set("gamma", value: gamma)
            }
            if let intOutput = intOutput {
                opt.set("int-output", value: intOutput)
            }
            opt.set("out", value: &out)

            try Self.call("globalbalance", options: &opt)
        }
    }

    /// Place an image within a larger image with a certain gravity
    ///
    /// - Parameters:
    ///   - direction: Direction to place image within width/height
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - extend: How to generate the extra pixels
    ///   - background: Color for background pixels
    public func gravity(direction: VipsCompassDirection, width: Int, height: Int, extend: VipsExtend? = nil, background: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("direction", value: direction)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let extend = extend {
                opt.set("extend", value: extend)
            }
            if let background = background {
                opt.set("background", value: background)
            }
            opt.set("out", value: &out)

            try Self.call("gravity", options: &opt)
        }
    }

    /// Ifthenelse an image
    ///
    /// - Parameters:
    ///   - in1: Source for TRUE pixels
    ///   - in2: Source for FALSE pixels
    ///   - blend: Blend smoothly between then and else parts
    public func ifthenelse(in1: some VIPSImageProtocol, in2: some VIPSImageProtocol, blend: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("cond", value: self)
            opt.set("in1", value: in1)
            opt.set("in2", value: in2)
            if let blend = blend {
                opt.set("blend", value: blend)
            }
            opt.set("out", value: &out)

            try Self.call("ifthenelse", options: &opt)
        }
    }

    /// Cache an image as a set of lines
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    ///   - access: Expected access pattern
    ///   - threaded: Allow threaded access
    ///   - persistent: Keep cache between evaluations
    public func linecache(tileHeight: Int? = nil, access: VipsAccess? = nil, threaded: Bool? = nil, persistent: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let tileHeight = tileHeight {
                opt.set("tile-height", value: tileHeight)
            }
            if let access = access {
                opt.set("access", value: access)
            }
            if let threaded = threaded {
                opt.set("threaded", value: threaded)
            }
            if let persistent = persistent {
                opt.set("persistent", value: persistent)
            }
            opt.set("out", value: &out)

            try Self.call("linecache", options: &opt)
        }
    }

    /// Map an image though a lut
    ///
    /// - Parameters:
    ///   - lut: Look-up table image
    ///   - band: Apply one-band lut to this band of in
    public func maplut(lut: some VIPSImageProtocol, band: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("lut", value: lut)
            if let band = band {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try Self.call("maplut", options: &opt)
        }
    }

    /// First-order match of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    public func match(sec: some VIPSImageProtocol, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int? = nil, harea: Int? = nil, search: Bool? = nil, interpolate: VIPSInterpolate? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let search = search {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            opt.set("out", value: &out)

            try Self.call("match", options: &opt)
        }
    }

    /// Measure a set of patches on a color chart
    ///
    /// - Parameters:
    ///   - h: Number of patches across chart
    ///   - v: Number of patches down chart
    ///   - `left`: Left edge of extract area
    ///   - top: Top edge of extract area
    ///   - width: Width of extract area
    ///   - height: Height of extract area
    public func measure(h: Int, v: Int, `left`: Int? = nil, top: Int? = nil, width: Int? = nil, height: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("h", value: h)
            opt.set("v", value: v)
            if let `left` = `left` {
                opt.set("left", value: `left`)
            }
            if let top = top {
                opt.set("top", value: top)
            }
            if let width = width {
                opt.set("width", value: width)
            }
            if let height = height {
                opt.set("height", value: height)
            }
            opt.set("out", value: &out)

            try Self.call("measure", options: &opt)
        }
    }

    /// Merge two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical merge
    ///   - dx: Horizontal displacement from sec to ref
    ///   - dy: Vertical displacement from sec to ref
    ///   - mblend: Maximum blend size
    public func merge(sec: some VIPSImageProtocol, direction: VipsDirection, dx: Int, dy: Int, mblend: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("dx", value: dx)
            opt.set("dy", value: dy)
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try Self.call("merge", options: &opt)
        }
    }

    /// Mosaic two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xref: Position of reference tie-point
    ///   - yref: Position of reference tie-point
    ///   - xsec: Position of secondary tie-point
    ///   - ysec: Position of secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - mblend: Maximum blend size
    ///   - bandno: Band to search for features on
    public func mosaic(sec: some VIPSImageProtocol, direction: VipsDirection, xref: Int, yref: Int, xsec: Int, ysec: Int, hwindow: Int? = nil, harea: Int? = nil, mblend: Int? = nil, bandno: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xref", value: xref)
            opt.set("yref", value: yref)
            opt.set("xsec", value: xsec)
            opt.set("ysec", value: ysec)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            if let bandno = bandno {
                opt.set("bandno", value: bandno)
            }
            opt.set("out", value: &out)

            try Self.call("mosaic", options: &opt)
        }
    }

    /// First-order mosaic of two images
    ///
    /// - Parameters:
    ///   - sec: Secondary image
    ///   - direction: Horizontal or vertical mosaic
    ///   - xr1: Position of first reference tie-point
    ///   - yr1: Position of first reference tie-point
    ///   - xs1: Position of first secondary tie-point
    ///   - ys1: Position of first secondary tie-point
    ///   - xr2: Position of second reference tie-point
    ///   - yr2: Position of second reference tie-point
    ///   - xs2: Position of second secondary tie-point
    ///   - ys2: Position of second secondary tie-point
    ///   - hwindow: Half window size
    ///   - harea: Half area size
    ///   - search: Search to improve tie-points
    ///   - interpolate: Interpolate pixels with this
    ///   - mblend: Maximum blend size
    public func mosaic1(sec: some VIPSImageProtocol, direction: VipsDirection, xr1: Int, yr1: Int, xs1: Int, ys1: Int, xr2: Int, yr2: Int, xs2: Int, ys2: Int, hwindow: Int? = nil, harea: Int? = nil, search: Bool? = nil, interpolate: VIPSInterpolate? = nil, mblend: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("ref", value: self)
            opt.set("sec", value: sec)
            opt.set("direction", value: direction)
            opt.set("xr1", value: xr1)
            opt.set("yr1", value: yr1)
            opt.set("xs1", value: xs1)
            opt.set("ys1", value: ys1)
            opt.set("xr2", value: xr2)
            opt.set("yr2", value: yr2)
            opt.set("xs2", value: xs2)
            opt.set("ys2", value: ys2)
            if let hwindow = hwindow {
                opt.set("hwindow", value: hwindow)
            }
            if let harea = harea {
                opt.set("harea", value: harea)
            }
            if let search = search {
                opt.set("search", value: search)
            }
            if let interpolate = interpolate {
                opt.set("interpolate", value: interpolate)
            }
            if let mblend = mblend {
                opt.set("mblend", value: mblend)
            }
            opt.set("out", value: &out)

            try Self.call("mosaic1", options: &opt)
        }
    }

    /// Pick most-significant byte from an image
    ///
    /// - Parameters:
    ///   - band: Band to msb
    public func msb(band: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let band = band {
                opt.set("band", value: band)
            }
            opt.set("out", value: &out)

            try Self.call("msb", options: &opt)
        }
    }

    /// Find threshold for percent of pixels
    ///
    /// - Parameters:
    ///   - percent: Percent of pixels
    public func percent(_ percent: Double) throws -> Int {
        var opt = VIPSOption()

        var out: Int = 0

        opt.set("in", value: self.image)
        opt.set("percent", value: percent)
        opt.set("threshold", value: &out)

        try Self.call("percent", options: &opt)

        return out
    }

    /// Prewitt edge detector
    public func prewitt() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("prewitt", options: &opt)
        }
    }

    /// Unpack Radiance coding to float RGB
    public func rad2float() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("rad2float", options: &opt)
        }
    }

    /// Rebuild an mosaiced image
    ///
    /// - Parameters:
    ///   - oldStr: Search for this string
    ///   - newStr: And swap for this string
    public func remosaic(oldStr: String, newStr: String) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("old-str", value: oldStr)
            opt.set("new-str", value: newStr)
            opt.set("out", value: &out)

            try Self.call("remosaic", options: &opt)
        }
    }

    /// Replicate an image
    ///
    /// - Parameters:
    ///   - across: Repeat this many times horizontally
    ///   - down: Repeat this many times vertically
    public func replicate(across: Int, down: Int) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("across", value: across)
            opt.set("down", value: down)
            opt.set("out", value: &out)

            try Self.call("replicate", options: &opt)
        }
    }

    /// Scharr edge detector
    public func scharr() throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("out", value: &out)

            try Self.call("scharr", options: &opt)
        }
    }

    /// Check sequential access
    ///
    /// - Parameters:
    ///   - tileHeight: Tile height in pixels
    public func sequential(tileHeight: Int? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            if let tileHeight = tileHeight {
                opt.set("tile-height", value: tileHeight)
            }
            opt.set("out", value: &out)

            try Self.call("sequential", options: &opt)
        }
    }

    /// Spatial correlation
    ///
    /// - Parameters:
    ///   - ref: Input reference image
    public func spcor(ref: some VIPSImageProtocol) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("ref", value: ref)
            opt.set("out", value: &out)

            try Self.call("spcor", options: &opt)
        }
    }

    /// Statistical difference
    ///
    /// - Parameters:
    ///   - width: Window width in pixels
    ///   - height: Window height in pixels
    ///   - s0: New deviation
    ///   - b: Weight of new deviation
    ///   - m0: New mean
    ///   - a: Weight of new mean
    public func stdif(width: Int, height: Int, s0: Double? = nil, b: Double? = nil, m0: Double? = nil, a: Double? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("in", value: self)
            opt.set("width", value: width)
            opt.set("height", value: height)
            if let s0 = s0 {
                opt.set("s0", value: s0)
            }
            if let b = b {
                opt.set("b", value: b)
            }
            if let m0 = m0 {
                opt.set("m0", value: m0)
            }
            if let a = a {
                opt.set("a", value: a)
            }
            opt.set("out", value: &out)

            try Self.call("stdif", options: &opt)
        }
    }

    /// Subsample an image
    ///
    /// - Parameters:
    ///   - xfac: Horizontal subsample factor
    ///   - yfac: Vertical subsample factor
    ///   - point: Point sample
    public func subsample(xfac: Int, yfac: Int, point: Bool? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("input", value: self)
            opt.set("xfac", value: xfac)
            opt.set("yfac", value: yfac)
            if let point = point {
                opt.set("point", value: point)
            }
            opt.set("out", value: &out)

            try Self.call("subsample", options: &opt)
        }
    }

}

extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {

#if SHIM_VIPS_VERSION_8_17
    /// Create an SDF image
    ///
    /// - Parameters:
    ///   - width: Image width in pixels
    ///   - height: Image height in pixels
    ///   - shape: SDF shape to create
    ///   - r: Radius
    ///   - a: Point a
    ///   - b: Point b
    ///   - corners: Corner radii
    public static func sdf(width: Int, height: Int, shape: VipsSdfShape, r: Double? = nil, a: [Double]? = nil, b: [Double]? = nil, corners: [Double]? = nil) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("width", value: width)
            opt.set("height", value: height)
            opt.set("shape", value: shape)
            if let r = r {
                opt.set("r", value: r)
            }
            if let a = a {
                opt.set("a", value: a)
            }
            if let b = b {
                opt.set("b", value: b)
            }
            if let corners = corners {
                opt.set("corners", value: corners)
            }
            opt.set("out", value: &out)

            try Self.call("sdf", options: &opt)
        }
    }
#endif

    /// Find the index of the first non-zero pixel in tests
    ///
    /// - Parameters:
    ///   - tests: Table of images to test
    public static func `switch`(tests: [VIPSImage]) throws -> Self {
        return try Self { out in
            var opt = VIPSOption()

            opt.set("tests", value: tests)
            opt.set("out", value: &out)

            try Self.call("switch", options: &opt)
        }
    }

}

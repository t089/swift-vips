//
//  FileWriter.swift
//  VIPSGenerator
//
//  Handles writing generated Swift code to files
//

import Foundation

struct FileWriter {
    let outputDirectory: URL

    init(outputDirectory: String) {
        self.outputDirectory = URL(fileURLWithPath: outputDirectory)
    }

    /// Write methods for a category to a file
    /// - Parameters:
    ///   - category: The category name (e.g., "Arithmetic", "Foreign/JPEG")
    ///   - methods: Array of tuples with nickname and generated code
    func writeCategory(_ category: String, methods: [(nickname: String, code: String)]) throws {
        // Determine file path based on category
        let (filepath, filename) = getFilePath(for: category)

        // Ensure directory exists
        let directory = filepath.deletingLastPathComponent()
        try ensureDirectoryExists(directory)

        // Check if any operations need CvipsShim import
        let needsCvipsShim = checkNeedsCvipsShim(methods: methods)

        // Separate operations into static and instance methods
        let (staticMethods, instanceMethods) = separateMethods(methods)

        // Generate file content
        let header = generateHeader(filename: filename, needsCvipsShim: needsCvipsShim)
        var content = header

        // Write instance methods
        if !instanceMethods.isEmpty {
            content += "extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {\n\n"

            for (_, code) in instanceMethods {
                content += code
                content += "\n\n"
            }

            // Add convenience methods for relational operations in the arithmetic category
            if category == "Arithmetic" {
                let overloads = OverloadGenerators()
                let relationalMethods = overloads.generateRelationalConvenienceMethods()
                if !relationalMethods.isEmpty {
                    content += relationalMethods
                    content += "\n\n"
                }
            }

            content += "}\n"
        }

        // Write static methods
        if !staticMethods.isEmpty {
            if !instanceMethods.isEmpty {
                content += "\n"
            }
            content += "extension VIPSImageProtocol where Self: ~Copyable /*, Self: ~Escapable */ {\n\n"

            for (_, code) in staticMethods {
                content += code
                content += "\n\n"
            }

            content += "}\n"
        }

        // Write to file
        try content.write(to: filepath, atomically: true, encoding: .utf8)
    }

    /// Generate the file header
    /// - Parameters:
    ///   - filename: The filename
    ///   - needsCvipsShim: Whether CvipsShim import is needed
    /// - Returns: The header string
    func generateHeader(filename: String, needsCvipsShim: Bool) -> String {
        var header = "//\n"
        header += "//  \(filename)\n"
        header += "//\n"
        header += "//  Generated by VIPS Swift Code Generator\n"
        header += "//  DO NOT EDIT - This file is automatically generated\n"
        header += "//\n\n"
        header += "import Cvips\n"
        if needsCvipsShim {
            header += "import CvipsShim\n"
        }
        header += "\n"
        return header
    }

    /// Ensure directory exists
    /// - Parameter path: The directory path
    func ensureDirectoryExists(_ path: URL) throws {
        let fileManager = FileManager.default
        if !fileManager.fileExists(atPath: path.path) {
            try fileManager.createDirectory(at: path, withIntermediateDirectories: true)
        }
    }

    // MARK: - Public helpers

    /// Get file path and filename for a category
    /// - Parameter category: The category name (e.g., "Arithmetic", "Foreign/JPEG")
    /// - Returns: Tuple of (filepath, filename)
    public func getFilePath(for category: String) -> (URL, String) {
        let categoryParts = category.split(separator: "/")

        if categoryParts.count > 1 {
            // Subcategory like Foreign/JPEG
            let mainCategory = String(categoryParts[0])
            let subCategory = String(categoryParts[1])
            let subDir = outputDirectory.appendingPathComponent(mainCategory)
            let filename = "foreign_\(subCategory.lowercased()).generated.swift"
            let filepath = subDir.appendingPathComponent(filename)
            return (filepath, filename)
        } else {
            // Top-level category like Arithmetic
            let filename = "\(category.lowercased()).generated.swift"
            let filepath = outputDirectory.appendingPathComponent(filename)
            return (filepath, filename)
        }
    }

    /// Check if any methods need CvipsShim import
    /// - Parameter methods: The methods to check
    /// - Returns: true if CvipsShim is needed
    private func checkNeedsCvipsShim(methods: [(nickname: String, code: String)]) -> Bool {
        for (_, code) in methods {
            // Check for various indicators that CvipsShim is needed
            if code.contains("vips_blob_copy") ||
               code.contains("vips_blob_new") ||
               code.contains("vips_array_double_get") ||
               code.contains("withVipsBlob") ||
               code.contains("shim_vips_area") {
                return true
            }
        }
        return false
    }

    /// Separate methods into static and instance methods
    /// - Parameter methods: The methods to separate
    /// - Returns: Tuple of (static methods, instance methods)
    private func separateMethods(_ methods: [(nickname: String, code: String)])
        -> ([(nickname: String, code: String)], [(nickname: String, code: String)])
    {
        var staticMethods: [(nickname: String, code: String)] = []
        var instanceMethods: [(nickname: String, code: String)] = []

        for method in methods {
            if method.code.contains("public static func") {
                staticMethods.append(method)
            } else {
                instanceMethods.append(method)
            }
        }

        return (staticMethods, instanceMethods)
    }
}
